<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hibernate（了解与使用）]]></title>
    <url>%2FHibernate%EF%BC%88%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89.html</url>
    <content type="text"><![CDATA[Hiberante的了解框架的概述框架（framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。什么是框架框架：指的是软件的半成品，已经完成了部分功能。EE的三层架构EE的经典三层结构Hibernate的概述Hibernate 是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JaveEE架构中取代CMP，完成数据持久化的重任。什么是HibernateHibernate是一种ORM框架，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象！什么是ORMORM：Object Relational Mapping（对象关系映射）。指的是将一个Java中的对象与关系型数据库中的表建立一种映射关系，从而操作对象就可以操作数据库中的表。为什么要学习Hibernate与其他操作数据库的技术相比，Hibernate具有以下几点优势Hibernate对 JBDC 访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。Hibernate 是一个基于 JDBC 的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化 DAO（Date Access Object，数据访问对象）层编码工作。Hibernate 的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。Hibernate的入门下载Hibernate开发环境Hibernate3.x &emsp; Hibernate4.x &emsp; Hibernate5.xhttps://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/解压 Hibernate解压完成会看到三个文件夹：documentation :Hibernate开发的文档lib :Hibernate开发包required :Hibernate开发的必须的依赖包optional :Hibernate开发的可选的jar包project :Hibernate提供的项目创建一个项目，引入jar包数据库驱动包Hibernate开发的必须的jar包Hibernate引入日志记录包创建表12345678910CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; @Override public String toString() &#123; return "Customer [cust_id=" + cust_id + ", cust_name=" + cust_name + ", cust_source=" + cust_source + ", cust_industry=" + cust_industry + ", cust_level=" + cust_level + ", cust_phone=" + cust_phone + ", cust_mobile=" + cust_mobile + "]"; &#125; &#125;创建映射映射需要通过XML的配置文件来完成，这个配置文件可以任意命名。尽量统一命名规范（类名.hbm.xml）123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;class name="com.hibernate.demo1.Customer" table="cst_customer"&gt; &lt;!-- 建立类中的属性与表中的主键对应 --&gt; &lt;id name="cust_id" column="cust_id" &gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name="cust_name" column="cust_name" length="32" /&gt; &lt;property name="cust_source" column="cust_source" length="32"/&gt; &lt;property name="cust_industry" column="cust_industry"/&gt; &lt;property name="cust_level" column="cust_level"/&gt; &lt;property name="cust_phone" column="cust_phone"/&gt; &lt;property name="cust_mobile" column="cust_mobile"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;创建一个Hibernate的核心配置文件Hibernate的核心配置文件的名称：hibernate.cfg.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;abc&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置================ --&gt; &lt;!-- 打印SQL --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;property name="connection.provider_class"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接的最少数目 --&gt; &lt;property name="c3p0.min_size"&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目 --&gt; &lt;property name="c3p0.max_size"&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间,以秒为单位, 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt; &lt;property name="c3p0.timeout"&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt; &lt;property name="c3p0.idle_test_period"&gt;3000&lt;/property&gt; &lt;mapping resource="com/hibernate/demo1/Customer.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;编写测试代码1234567891011121314151617181920212223242526272829public class HibernateDemo1 &#123; @Test // 保存客户的案例 public void demo1()&#123; // 1.加载Hibernate的核心配置文件 Configuration configuration = new Configuration().configure(); // 手动加载映射 // configuration.addResource("com/itheima/hibernate/demo1/Customer.hbm.xml"); // 2.创建一个SessionFactory对象：类似于JDBC中连接池 SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3.通过SessionFactory获取到Session对象：类似于JDBC中Connection Session session = sessionFactory.openSession(); // 4.手动开启事务： Transaction transaction = session.beginTransaction(); // 5.编写代码 Customer customer = new Customer(); customer.setCust_name("王西"); session.save(customer); // 6.事务提交 transaction.commit(); // 7.资源释放 session.close(); sessionFactory.close(); &#125;&#125;Hibernate的常见配置Hibernate的映射的配置映射的配置【class标签的配置】标签用来建立类与表的映射关系属性：name ：类的全路径table ：表名（类名与表名一致，table可以省略）catalog ：数据库名【id标签的配置】标签用来建立类中的属性与表中的主键的对应关系属性：name ：类中的属性名column ：表中的字段名（类中的属性名和表中的字段名如果一致，column可以省略）length ：长度type ：类型【property标签的配置】标签用来建立类中的普通属性与表的字段的对应关系属性：name ：类中的属性名column ：表中的字段名length ：长度type ：类型not-null ：设置非空unique ：设置唯一Hibernate的核心的配置Hibernate的核心配置方式（了解）一种方式:属性文件的方式hibernate.propertieshibernate.connection.driver_class=com.mysql.jdbc.Driver…hibernate.show_sql=true属性文件的方式不能引入映射文件（手动编写代码加载映射文件）二种方式:XML文件的方式hibernate.cfg.xml核心的配置必须的配置连接数据库的基本的参数驱动类url路径用户名密码方言可选的配置显示SQL ：hibernate.show_sql格式化SQL ：hibernate.format_sql自动建表 ：hibernate.hbm2ddl.autonone ：不使用hibernate的自动建表create ：如果数据库中已经有表，删除原有表，重新创建，如果没有表，新建表。（测试）create-drop ：如果数据库中已经有表，删除原有表，执行操作，删除这个表。如果没有表，新建一个，使用完了删除该表。（测试）update ：如果数据库中有表，使用原有表，如果没有表，创建新表（更新表结构）validate ：如果没有表，不会创建表。只会使用数据库中原有的表。（校验映射和表结构）。映射文件的引入引入映射文件的位置Hibernate的核心APIHibernate的APIConfiguration：Hibernate的配置对象Configurationconfiguration类的作用是对Hibernate进行配置，以及对它进行启动，在启动过程中，Configuration类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象，虽然Configuration类在整个Hibernate项目中只扮演着一个很小的角色，但它是启动hibernate时所遇到的第一个对象作用：加载核心配置文件hibernate.propertiesConfiguration cfg = new Configuration();hibernate.cfg.xmlConfiguration cfg = new Configuration().configure();加载映射文件12// 手动加载映射configuration.addResource("com/itheima/hibernate/demo1/ Customer.hbm.xml");SessionFactory：Session工厂SessionFactorySessionFactory接口负责初始化Hibernate，它充当数据存储源的代理，并负责创建Session对象，这里用到了工厂模式。需要注意的事SessionFactory并不是轻量级的，因为在一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个库指定一个SessionFactory。SessionFactory内部维护了Hibernate的连接池和Hibernate的二级缓存。是线程安全的对象。一个项目创建一个对象即可。配置连接池：（了解）1234567891011&lt;!-- 配置C3P0连接池 --&gt; &lt;property name="connection.provider_class"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接的最少数目 --&gt; &lt;property name="c3p0.min_size"&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目 --&gt; &lt;property name="c3p0.max_size"&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间,以秒为单位, 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt; &lt;property name="c3p0.timeout"&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt; &lt;property name="c3p0.idle_test_period"&gt;3000&lt;/property&gt;抽取工具类1234567891011121314public class HibernateUtils &#123; public static final Configuration cfg; public static final SessionFactory sf; static&#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; public static Session openSession()&#123; return sf.openSession(); &#125;&#125;Session：类似Connection对象是连接对象Session接口负责执行被持久化对象的CRUD操作（CRUD的任务是完成与数据库的交流，包含很多藏剑的SQL语句）。但需要注意的事Session对象是非线程安全的。同时，Hibernate的Session不同于JSP应用中的HttpSession。这里当使用Session这个术语时，其实指的是Hibernate中的Session，而以后会将HttpSession对象称为用户Session。Session代表的是Hibernate与数据库的链接对象。不是线程安全的。与数据库交互桥梁。Session中的API保存方法：Serializable save(Object obj);查询方法：T get(Class c,Serializable id);T load(Class c,Serializable id);get方法和load方法的区别？12345678910111213141516171819202122232425public void demo2()&#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); /** * get方法 * * 采用的是立即加载，执行到这行代码的时候，就会马上发送SQL语句去查询。 * * 查询后返回是真实对象本身。 * * 查询一个找不到的对象的时候，返回null * * load方法 * * 采用的是延迟加载（lazy懒加载），执行到这行代码的时候，不会发送SQL语句，当真正使用这个对象的时候才会发送SQL语句。 * * 查询后返回的是代理对象。javassist-3.18.1-GA.jar 利用javassist技术产生的代理。 * * 查询一个找不到的对象的时候，返回ObjectNotFoundException */ // 使用get方法查询 /*Customer customer = session.get(Customer.class, 100l); // 发送SQL语句 System.out.println(customer);*/ // 使用load方法查询 Customer customer = session.load(Customer.class, 200l); System.out.println(customer); tx.commit(); session.close(); &#125;修改方法void update(Object obj);123456789101112131415161718public void demo3()&#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 直接创建对象，进行修改 /*Customer customer = new Customer(); customer.setCust_id(1l); customer.setCust_name("王聪"); session.update(customer);*/ // 先查询，再修改(推荐) Customer customer = session.get(Customer.class, 1l); customer.setCust_name("王小贱"); session.update(customer); tx.commit(); session.close(); &#125;删除方法void delete(Object obj);1234567891011121314151617// 删除操作 public void demo4()&#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 直接创建对象，删除 /* Customer customer = new Customer(); customer.setCust_id(1l); session.delete(customer);*/ // 先查询再删除(推荐)--级联删除 Customer customer = session.get(Customer.class, 2l); session.delete(customer); tx.commit(); session.close(); &#125;保存或更新void saveOrUpdate(Object obj)12345678910111213141516public void demo5()&#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); /*Customer customer = new Customer(); customer.setCust_name("王凤"); session.saveOrUpdate(customer);*/ Customer customer = new Customer(); customer.setCust_id(3l); customer.setCust_name("李如花"); session.saveOrUpdate(customer); tx.commit(); session.close(); &#125;查询所有1234567891011121314151617181920// 查询所有 public void demo6()&#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 接收HQL：Hibernate Query Language 面向对象的查询语言 /*Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125;*/ // 接收SQL： SQLQuery query = session.createSQLQuery("select * from cst_customer"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit(); session.close(); &#125;Transaction：事务对象Hibernate中管理事务的对象。commit();rollback();主键生成策略&amp;一级缓存&amp;事物管理Hibernate持久化类的编写规则什么是持久化类Hibernate 是持久层的ORM映射框架，专注于数据的持久化工作。所谓的持久化，就是将内存中的数据永久存储到关系型数据库中。那么知道了什么是持久化，什么又是持久化类呢？其实所谓的持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。持久化类的编写规则我们在编写持久化类的时候需要有以下几点需要注意：持久化类需要提供无参数的构造方法。因为在Hibernate的底层需要使用反射生成类的实例。持久化类的属性需要私有，对私有的属性提供公有的get和set方法。因为在Hibernate底层会将查询到的数据进行封装。持久化类的属性要尽量使用包装类的类型。因为包装类和基本数据类型的默认值不同，包装类的类型语义描述更清晰而基本数据类型不容易描述。持久化类要有一个唯一标识OID与表的主键对应。因为Hibernate中需要通过这个唯一标识OID区分在内存中是否是同一个持久化类。在Java中通过地址区分是否是同一个对象的，在关系型数据库的表中式通过主键区分是否同一条记录。那么Hibernate就是通过这个OID来进行区分的。Hibernate是不允许在内存中出现两个ODI相同的持久化对象的。持久化类尽量不要使用final进行修饰。因为Hibernate中有延迟加载的机制，这个机制中会产生代理对象，Hibernate产生代理对象使用的是字节码的增强技术完成的，其实就是产生了当前类的一个子类对象实现的。如果使用了final修饰持久化类。那么久不能产生子类，从而就不会产生代理对象，那么Hibernate的延迟加载策略（是一种优化手段）就会失效。Hibernate主键生成策略主键的类型在讲解Hibernate的逐渐生成策略之前，先来了解两个概念，即自然主键和代理主键，具体如下：自然主键：把具有业务含义的字段作为主键，称之为自然主键。例如在customer表中，如果把那么字段作为主键，其前提条件必须是：每一个客户的姓名不允许为null，不允许客户重名，并且不允许修改客户姓名。尽管着也是可行的，但是不能满足不断变化的业务需求，一旦出现了允许客户重名的业务需求，就必须修改数据模型，重新定义表的主键，这给数据库的维护增加了难度。代理主键：把不具备业务含义的字段作为主键，称之为代理主键。该字段一般取名为“ID”，通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间。Hibernate的主键生成策略：Hibernate中，提供了几个内置的主键生成策略，其常用主键生成策略的名称和描述如下名称描述increment用于long、short、或int类型，由Hibernate自动以递增的方式生成唯一标识符，每次增量为1。只有当没有用其它进程想同一张表中插入数据时才可以使用，不能在集群环境下使用。适用于代理主键。identity采用底层数据库本身提供的主键生成标识符，条件是数据库支持自动增长数据类型。在DB2、MySQL、MS SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增长类型。适用于代理主键。sequenceHiberante根据底层数据库序列生成标识符。条件是数据库支持序列。适用于代理主键。native根据底层数据库对自动生成标识符的能力来选择identity、sequence、hilo三种生成器中的一种，适合跨数据库平台开发。适用于代理主键。uuidHibernate采用128位的UUID算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32为的十六进制字符串。这种策略并不流行，因为字符串类型的主键比整数类型的主键占用更多的数据库空间。适用于代理主键。assigned由java程序负责生成标识符，如果不指定id元素的generator属性，则默认使用该主键策略。适用于自然主键。Hibernate的持久化对象的三种状态持久化对象三种状态的概述了解了主键的生成策略之后，我们可以进一步来了解持久化类了。Hibernate为了更好的来管理持久化类，特将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为三种状态，分别是瞬时态、持久态和脱管态，一个持久化类的实例可能处于三种不同状态中的某一种，三种状态详细介绍如下。瞬时态（transient）也被称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hiberante Session关联，在数据库中也米有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中式孤立存在的，与数据库中的数据无如何关联，仅是一个信息携带的载体。持久态（persistent）的对象存在持久化标识OID，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。脱管态（detached）也被称为离线态或者游离态，当某个持久化状态的实例与Session的管理被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。区分对象的三种状态为了帮助大家更好的理解持久化对象的三种状态，接下来通过具体的案例来演示持久化对象的三种状态。12345678910111213141516171819202122232425//测试对象的三种状态public class Demo &#123; @Test //查看三种状态 public void fun1()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 Customer c = new Customer(); // 没有id, 没有与session关联 =&gt; 瞬时状态 c.setCust_name("联想"); // 瞬时状态 Serializable id = session.save(c); // 持久化状态, 有id,有关联 //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 System.out.println(c);//托管态对象：有持久化标识OID，没有被session管理 &#125;&#125;c 对象由new关键字创建,此时还未与Session进行关联，它的状态称为瞬时态；在执行了session.save(c)操作后，c对象纳入了Session的管理范围，这时的 c 对象变成了持久态对象，此时Session的事务还没有被提交；程序执行完commit()操作并关闭了Session后，c对象与Session的关联被关闭，此时 c 对象就变成脱管态。Hibernate持久化对象的三种状态转换从图中可以看出，当一个对象被执行new关键字创建后，该对象处于瞬时态；当对瞬时态对象执行Session的save()或saveOrUpdate()方法后，该对象将被放入Session的以及缓存，对象进入持久态；当对持久态对象执行evict()、close()或clear()操作后，对象进入托管态；当直接执行Session的get()、load()、find()或iterate()等方法从数据库里查询对象时，查询到的对象也处于持久态；当对数据库中的记录进行update()、saveOrUpdate()以及lock()等操作后，此时脱管态的对象就过渡到持久态；由于瞬时态和脱管态的对象不在session的管理范围，所以会在一段时间后被JVM回收。持久化对象的三种状态可以通过调用Session中的一系列方法实现状态间的转换，具体如下：瞬时态转换到其他状态通过前面学习可知，瞬时态的对象由new关键字创建，瞬时态对象转换到其他状态总结如下：瞬间态转换为持久态：执行Session的save()或saveOrUpdate()方法。瞬时态转换为脱管态：为瞬时态对象设置持久化标识OID。由于持久化对象状态演化图中没有涉及到瞬时态转换到脱管态的情况，这里做下简要的说明，在前面学习中可知，脱管态对象窜OID，但是没有Session的关联，也就是说脱管态和瞬时态的区别就是OID有没有值，所以可以通过为瞬时态对象设置OID，使其变成脱管态对象。12Customer customer = new Customer(); //瞬时态customer.setCust_id(1); //脱管态持久态对象转换到其他状态持久化对象可以直接通过Hibernate中Session的get()、load()方法，或者Query查询从数据库中获得，持久态对象转换到其他的状态总结如下：持久态转换为瞬时态：执行Session的delete()方法，需要注意的是被删除的持久化对象，不建议再次使用持久态转换为脱管态：执行Session的evict()、close()或clear()方法。evict()方法用于清除异己缓存的所有对象。脱管态对象转换到其他状态脱管态对象无法直接获得，是由其他状态对象转换而来的，脱管态对象转换到其他状态总结如下：脱管态转换为持久态：执行Session的update()、saveOrUpdate()或lock()方法。脱管态转换为瞬时态：将脱管态对象的持久化标识OID设置为null。由于持久化对象状态演化图中没有涉及到脱管态换到瞬时态的情况，这里做下简要的说明，跟瞬时态转换到脱管态的情况相似，脱管态和瞬时态的区别就是OID有没有值，所以可以通过将脱管对象的OID设置为null，使其变成瞬时态对象。例如在session.close()操作后，加入代码customer.setCust_id(null);，customer对象将由脱管态转换为瞬时态。持久态对象能够自动更新数据库我们已经持久化对象的三种状态了，其实我们主要去研究持久态对象就够了，持久态对象其实有一个非常重要的特性：持久态对象可以自动更新数据库。123456789101112131415161718// 持久化状态特点: 持久化状态对象的任何变化都会自动同步到数据库中. public void fun3()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 Customer c = session.get(Customer.class, 1l);//持久化状态对象 c.setCust_name("微软公司"); //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125;执行测试我们会发现，我们并没有手动调用update方法，Hibernate就可以将数据自动更新了。持久态对象就有这样的一个功能。持久态对象之所以有这样的功能其实都依赖了Hibernate的一级缓存。接下来我们就开始学习Hibernate缓存。Hibernate的一级缓存缓存是计算机领域非常通用的概念。它介于应用程序和永久性数据存储源(如硬盘上的文件或者数据库）之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。缓存中的数据是数据存储源中数据的拷贝。缓存的物理介质通常是内存。Hibernate的缓存分为一级缓存和二级缓存,Hibernate的这两级缓存都位于持久化层，存储的都是数据的备份。其中第一级缓存为Hibernate的内置缓存，不能被卸载。接下来围绕Hibernate的一级缓存进行详细地讲解。什么是Hibernate的一级缓存Hibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就知己将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate的一级缓存的作用就是减少对数据库的访问次数。在Session接口的实现中包含一系列的Java集合，这些Java集合构成了Session缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。Hibernate的一级缓存有如下特点：当应用程序调用Session接口的save()、update()、saveOrUpdate，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。当调用Session接口的load()、get()方法，一级Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，在去数据库中查询对应对象，并添加到一级缓存中。当调用Session的close()方法时，Session缓存会被清空。测试一级缓存我们已经大致了解什么是一级缓存，那么一级缓存具体是否存在呢，我们可以通过如下的程序来证明以及缓存是存在的。1234567891011121314@Test//证明Hibernate的一级缓存的存在：public void demo1()&#123; Sesion session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer1 = session.get(Customer.class,1l)//马上发送一条sql查询1号客服，并将数据存入了一级缓存 System.out.println(customer1); Customer customer2 = session.get(Customer.class,1l)//没有发生SQL语句从一级缓存中获取数据 System.out.println(customer2); System.out.println(customer1 == customer2);//true 一级缓存 缓存的是对象的地址。 tx.commit(); session.close();&#125;在以上代码中，第一次执行Session的get()方法获取customer1对象时，由于一级缓存中没有数据，所以Hibernate会向数据库发送一条sql语句，查询id等于1的对象；当再次调用了session的get()方法获取customer2对象时，将不会再发送sql语句，这是因为customer2对象是从一级缓存中获取的。一级缓存的内部结构：（快照区）Hibernate向一级缓存放入数据时，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。Hibernate 的事务控制Hibernate是对JDBC的轻量级封装，其主要功能是操作数据库。在操作数据库过程中，经常会遇到事务处理的问题，那么我们接下来就来介绍Hibernate中的事务管理。什么是事务在数据库操作中，一项事务(Transaction)是由一条或多条操作数据库的SQL语句组成的一个不可分割的工作单元。当食物中的所有操作都正常完成时，整个事务才能被提交到数据库中，如果有一项操作没有完成，则整个事务都会被回滚。事务的四个特性事务有很严格的定义，需要同时满足四个特性，即原子性、一致性、隔离性、持久性。这四个特性通常称之为ACID特性，具体如下：原子性（Atomic）: 表示将事务中所做的操作捆绑成一个不可分割的单元，即对事务所进行的数据修改等操作，要么全部执行，要么全都不执行。一致性（Consistency）: 表示事务完成时，必须使所有的数据都保持一致状态。隔离性（Isolation）: 指一个事物的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离性的，并发执行的各个事务之间不能相互干扰。持久性（Durability）: 持久性也称为永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。提交后的其他操作或故障不会对其有任何影响。事务的并发问题在实际应用过程中，数据库是要被多个用户所共同访问的。在多个事务同时使用相同的数据时，可能会发生并发的问题，具体如下。脏读：一个事务读取到另一个事务未提交的数据。不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致在同一个事务中的多次查询结果不一致。虚读/幻读：一个事务读到了另一个事务已经提交的insert的数据，导致在同一个事务中的多次查询结果不一致事务的隔离级别为了避免事务并发问题的发生，在标准SQL规范中，定义了4个事务隔离级别，不同隔离级别对事务的处理不同。读未提交（ReadUncommitted，1级）：一个事务在执行过程中，既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。此隔离级别可防止丢失更新。已提交读（Read Committed，2级）：一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别可有效防止脏读。可重复读（Repeatable Read，4级）：一个事务在执行过程中，可以访问其他事务成功提交的新插入数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务，此隔离级别可有效的防止不可重复读和脏读。序列化/串行化（Serializable，8级）：提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。此隔离级别可有效的防止脏读、不可重复读和幻读。隔离级别含义READ_UNCOMMITTED允许你读取还未提交的改变了的数据。可能导致脏、幻、不可重复读READ_COMMITED允许在并发事务已经提交后读取。可防止脏读，但幻读和不可重复读仍可发生REPEATABLE_READ对相同字段的多次读取是一致的，除非数据被事务本身改变。可以防止脏、不可重复读，但幻读仍可能发生。SERIALIZABLE完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的事务的隔离界别，是由数据库提供的，并不是所有数据库都支持四种隔离级别MySQL：READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE(默认 REPEATABLE_READ)Oracle：READ_UNCOMMITTED、READ_COMMITTED、SERIALIZABLE(默认 READ_COMMITTED)在使用数据库时候，隔离级别越高，安全性越高，性能越低。实际开发中，不会选择最高或者最低隔离级别，选择READ_COMMITTED(Oracle 默认)、REPEATABLE_READ(Mysql 默认)Hibernate 中的事务管理在 Hibernate 中，可以通过代码来操作管理实务，如通过 Transaction tx = session.beginTransaction(); 开启一个事务；持久化操作后，通过 tx.commit();提交事务；如果食物出现异常，又通过tx.rollback();操作来撤销事务（事务回滚）。除了在代码块中队事务开启，提交和回滚操作外，还可以在 Hibernate 的配置文件中队事务进行配置。配置文件中，可以设置事务的隔离级别。其具体的配置方法是在 hibernate.cfg.xml 文件中的&lt;session-factory&gt;标签元素中进行的。配置方法如下所示。1234567891011&lt;!-- 引入orm元数据 路径书写: 填写src下的路径 --&gt; &lt;!-- 指定hibernate操作数据库时的隔离级别 #hibernate.connection.isolation 1|2|4|8 0001 1 读未提交 0010 2 读已提交 0100 4 可重复读 1000 8 串行化 --&gt; &lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt;到这我们已经设置了事务的隔离级别，那么我们在真正进行事务管理的时候，需要考虑事务的应用的场景，也就是说我们的事务控制不应该是在DAO层实现的，应该在Service层实现，并且在Service中调用多个Dao实现一个业务逻辑的操作。具体操作如下显示：其实最主要的是如何保证在Service中开启的事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。其实有两个方法可以实现：可以在业务层获取到Session，并将Session作为参数传递给DAO。可以使用ThreadLocal将业务层获取的Session绑定到当前线程中，然后再DAO中获取Session的时候，都从当前线程中获取。其实使用第二种方式肯定是最优方案，那么具体的实现已经不用我们来完成了，Hibernate的内部已经将这个事情做完了。我们只需要完成一段配置即可。Hibernate5中自身提供了三种管理Session对象的方法Session对象的生命周期与本地线程绑定、Session对象的生命周期与 JTA 事务绑定Hibernate委托程序管理 Session 对象的生命周期在 Hibernate 的配置文件中，hibernate.current_session_context_class 属性用于指定 Session 管理方式，可选值包括Thread：Session对象的生命周期与本地线程绑定jta： Session对象的生命周期与JTA事务绑定managed： Hibernate 委托程序来管理 Session 对象的生命周期在hibernate.cfg.xml中进行如下配置：12&lt;!-- 指定session与当前线程绑定 --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt;hibernate提供sessionFactory.getCurrentSession()创建一个session和ThreadLocal绑定方法。在HibernateUtil工具类中更改getCurrentSession方法：1234//获取当前线程绑定的会话public static Session getCurrentSession()&#123; return sessionFactory.getCurrentSession();&#125;而且Hibernate中提供的这个与线程绑定的 session 可以不用关闭，当线程执行结束后，就会自动关闭了。Hibernate的其他APIQueryQuery代表面向对象的一个 Hibernate 查询操作。在 Hibernate 中，通常使用session.createQuery()方法接受一个HQL语句，然后调用 Query 的list()或uniqueResult() 方法执行查询。所谓的 HQL 是Hibernate Query Language 缩写，其语法很像 SQL 语法，但它是完全面向对象的。在 Hibernate中使用 Query对象的步骤，具体所示：获得Hibernate的Session对象。编写HQL语句。调用session.createQuery 创建查询对象。如果HQL语句包含参数，则调用Query的 setXxx 设置参数。调用 Query 对象的 list()或 uniqueResult() 方法执行查询。了解了使用 Query 对象的步骤后，接下来，通过具体示例来演示 Query 对象的查询操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//测试HQL语句public class Demo &#123; @Test //基本查询 public void fun1()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句// String hql = " from cn.itheima.domain.Customer "; String hql = " from Customer "; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //3&gt; 根据查询对象获得查询结果 List&lt;Customer&gt; list = query.list(); // 返回list结果 //query.uniqueResult();//接收唯一的查询结果 System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //条件查询 //HQL语句中,不可能出现任何数据库相关的信息的 public void fun2()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句 String hql = " from Customer where cust_id = 1 "; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //3&gt; 根据查询对象获得查询结果 Customer c = (Customer) query.uniqueResult(); System.out.println(c); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //条件查询 //问号占位符 public void fun3()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句 String hql = " from Customer where cust_id = ? "; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //设置参数 //query.setLong(0, 1l); query.setParameter(0, 1l); //3&gt; 根据查询对象获得查询结果 Customer c = (Customer) query.uniqueResult(); System.out.println(c); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //条件查询 //命名占位符 public void fun4()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句 String hql = " from Customer where cust_id = :cust_id "; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //设置参数 query.setParameter("cust_id", 1l); //3&gt; 根据查询对象获得查询结果 Customer c = (Customer) query.uniqueResult(); System.out.println(c); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //分页查询 public void fun5()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句 String hql = " from Customer "; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //设置分页信息 limit ?,? query.setFirstResult(1); query.setMaxResults(1); //3&gt; 根据查询对象获得查询结果 List&lt;Customer&gt; list = query.list(); System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125;&#125;Query中出来使用list()方法查询全部数据外，还有其它一些常用方法，具体如下：setter方法： Query接口中提供了一系列的 setter 方法用于设置查询语句的参数，针对不同的数据类型，需要用到不同的setter方法。iterator()方法：该方法用于查询语句，返回的结果是一个Iterator对象，在读取时只能按照顺序方式读取，它仅把使用到的数据转换成Java实体对象。uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法。executeUpdate()方法：该方法是 Hibernate 的新特性，它支持 HQL 语句的更新和删除操作。setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算。setMaxResult()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult() 方法结合使用，用于限制结果集的范围，以实现分页功能。CriteriaCriteria 是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。Criteria查询，又称为 QBC 查询（Query By Criteria），它是Hibernate的另一种对象检索方式。org.hibernate.criterion.Criterion是 Hibernate 提供的一个面向对象查询条件接口，一个单独的查询就是 Criterion 接口的一个实例，用于限制 Criteria 对象的查询，在 Hibernate 中 Criterion 对象的创建通常是通过 Restrictions 工厂类完成的，它提供饿了条件查询方法。通常，使用 Criteria 对象查询数据的主要步骤，具体如下：获得Hibernate的 Session 对象。通过 Session 获得 Criteria 对象。使用 Restrictions 的静态方法创建 Criterion 条件对象。Restrictions 类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criterion 实例，每个 Criterion 实例代表一个查询条件。向 Criteria 对象中添加 Criterion 查询条件。Criteria的 add() 方法用于查询条件。执行 Criterita 的 list() 或 uniqueResult() 获得结果。了解了 Criteria 对象的使用步骤后，接下来，通过具体示例来演示 Criterria 对象的查询操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//测试Criteria查询public class Demo &#123; @Test //基本查询 public void fun1()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //查询所有的Customer对象 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); // Customer c = (Customer) criteria.uniqueResult(); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //条件查询 //HQL语句中,不可能出现任何数据库相关的信息的 // &gt; gt // &gt;= ge // &lt; lt // &lt;= le // == eq // != ne // in in // between and between // like like // is not null isNotNull // is null isNull // or or // and and public void fun2()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //创建criteria查询对象 Criteria criteria = session.createCriteria(Customer.class); //添加查询参数 =&gt; 查询cust_id为1的Customer对象 criteria.add(Restrictions.eq("cust_id", 1l)); //执行查询获得结果 Customer c = (Customer) criteria.uniqueResult(); System.out.println(c); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //分页查询 public void fun3()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //创建criteria查询对象 Criteria criteria = session.createCriteria(Customer.class); //设置分页信息 limit ?,? criteria.setFirstResult(1); criteria.setMaxResults(2); //执行查询 List&lt;Customer&gt; list = criteria.list(); System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //查询总记录数 public void fun4()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //创建criteria查询对象 Criteria criteria = session.createCriteria(Customer.class); //设置查询的聚合函数 =&gt; 总行数 criteria.setProjection(Projections.rowCount()); //执行查询 Long count = (Long) criteria.uniqueResult(); System.out.println(count); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125;&#125;SQLQuerySQLQuery 这个就比较简单了，这个接口用于接收一个sql语句进行查询，然后调用 list()或者 uniqueResult() 方法进行查询。但是 sql 语句不会直接封装到实体对象中，需要我们手动写代码才可以封装到实体中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//测试原生SQL查询public class Demo &#123; @Test //基本查询 public void fun1()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1 书写sql语句 String sql = "select * from cst_customer"; //2 创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //3 调用方法查询结果 List&lt;Object[]&gt; list = query.list(); //query.uniqueResult(); for(Object[] objs : list)&#123; System.out.println(Arrays.toString(objs)); &#125; //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //基本查询 public void fun2()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1 书写sql语句 String sql = "select * from cst_customer"; //2 创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //指定将结果集封装到哪个对象中 query.addEntity(Customer.class); //3 调用方法查询结果 List&lt;Customer&gt; list = query.list(); System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //条件查询 public void fun3()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1 书写sql语句 String sql = "select * from cst_customer where cust_id = ? "; //2 创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); query.setParameter(0, 1l); //指定将结果集封装到哪个对象中 query.addEntity(Customer.class); //3 调用方法查询结果 List&lt;Customer&gt; list = query.list(); System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125; @Test //分页查询 public void fun4()&#123; //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1 书写sql语句 String sql = "select * from cst_customer limit ?,? "; //2 创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); query.setParameter(0, 0); query.setParameter(1, 1); //指定将结果集封装到哪个对象中 query.addEntity(Customer.class); //3 调用方法查询结果 List&lt;Customer&gt; list = query.list(); System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 &#125;&#125;Hibernate的进阶表操作-多对多配置数据库表与表之间的关系一对多关系什么样关系属于一对多？一个部门对应多个员工，一个员工只能属于某一个部门。一个客户对应多个联系人，一个联系人只能属于某一个客服。多对多关系什么关系属于多对多？一个学生可以选择多门课程，一门课程也可以被多个学生选择。一个用户可以选择多个角色，一个角色也可以被多个用户选择一对一关系（了解）什么样关系属于一对一？一个公司只能有一个注册地址，一个注册地址只能被一个公司注册。Hibernate 一对多的关系配置创建一个项目，引入相应 jar 包创建数据库和表12345678910111213141516171819202122232425262728CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `cst_linkman` ( `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名', `lkm_cust_id` bigint(32) DEFAULT NULL COMMENT '客户id', `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别', `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话', `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机', `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱', `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq', `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位', `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;创建实体一的一方的实体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; // 通过ORM方式表示：一个客户对应多个联系人。 // 放置的多的一方的集合。Hibernate默认使用的是Set集合。 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; public Set&lt;LinkMan&gt; getLinkMans() &#123; return linkMans; &#125; public void setLinkMans(Set&lt;LinkMan&gt; linkMans) &#123; this.linkMans = linkMans; &#125; &#125;多的一方的实体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class LinkMan &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; // 通过ORM方式表示：一个联系人只能属于某一个客户。 // 放置的是一的一方的对象。 private Customer customer; public Long getLkm_id() &#123; return lkm_id; &#125; public void setLkm_id(Long lkm_id) &#123; this.lkm_id = lkm_id; &#125; public String getLkm_name() &#123; return lkm_name; &#125; public void setLkm_name(String lkm_name) &#123; this.lkm_name = lkm_name; &#125; public String getLkm_gender() &#123; return lkm_gender; &#125; public void setLkm_gender(String lkm_gender) &#123; this.lkm_gender = lkm_gender; &#125; public String getLkm_phone() &#123; return lkm_phone; &#125; public void setLkm_phone(String lkm_phone) &#123; this.lkm_phone = lkm_phone; &#125; public String getLkm_mobile() &#123; return lkm_mobile; &#125; public void setLkm_mobile(String lkm_mobile) &#123; this.lkm_mobile = lkm_mobile; &#125; public String getLkm_email() &#123; return lkm_email; &#125; public void setLkm_email(String lkm_email) &#123; this.lkm_email = lkm_email; &#125; public String getLkm_qq() &#123; return lkm_qq; &#125; public void setLkm_qq(String lkm_qq) &#123; this.lkm_qq = lkm_qq; &#125; public String getLkm_position() &#123; return lkm_position; &#125; public void setLkm_position(String lkm_position) &#123; this.lkm_position = lkm_position; &#125; public String getLkm_memo() &#123; return lkm_memo; &#125; public void setLkm_memo(String lkm_memo) &#123; this.lkm_memo = lkm_memo; &#125; public Customer getCustomer() &#123; return customer; &#125; public void setCustomer(Customer customer) &#123; this.customer = customer; &#125; &#125;创建映射文件多的一方的映射的创建1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.domain.LinkMan" table="cst_linkman"&gt; &lt;!-- 建立OID与主键映射 --&gt; &lt;id name="lkm_id" column="lkm_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表字段映射 --&gt; &lt;property name="lkm_name"/&gt; &lt;property name="lkm_gender"/&gt; &lt;property name="lkm_phone"/&gt; &lt;property name="lkm_mobile"/&gt; &lt;property name="lkm_email"/&gt; &lt;property name="lkm_qq"/&gt; &lt;property name="lkm_position"/&gt; &lt;property name="lkm_memo"/&gt; &lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt; &lt;!-- many-to-one标签 * name :一的一方的对象的属性名称。 * class :一的一方的类的全路径。 * column :在多的一方的表的外键的名称。 --&gt; &lt;many-to-one name="customer" class="com.hibernate.domain.Customer" column="lkm_cust_id"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;一的一方的映射的创建1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.domain.Customer" table="cst_customer"&gt; &lt;!-- 建立OID与主键映射 --&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与数据库表字段映射 --&gt; &lt;property name="cust_name" column="cust_name" /&gt; &lt;property name="cust_source" column="cust_source"/&gt; &lt;property name="cust_industry" column="cust_industry"/&gt; &lt;property name="cust_level" column="cust_level"/&gt; &lt;property name="cust_phone" column="cust_phone"/&gt; &lt;property name="cust_mobile" column="cust_mobile"/&gt; &lt;!-- 配置一对多的映射：放置的多的一方的集合 --&gt; &lt;!-- set标签 ： * name ：多的一方的对象集合的属性名称。 * cascade：级联 * inverse：放弃外键维护权。 --&gt; &lt;set name="linkMans" cascade="save-update" inverse="true"&gt; &lt;!-- key标签 * column：多的一方的外键的名称。 --&gt; &lt;key column="lkm_cust_id"/&gt; &lt;!-- one-to-many标签 * class :多的一方的类的全路径 --&gt; &lt;one-to-many class="com.hibernate.domain.LinkMan"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;创建核心配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;abc&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置================ --&gt; &lt;!-- 打印SQL --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;property name="connection.provider_class"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接的最少数目 --&gt; &lt;property name="c3p0.min_size"&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目 --&gt; &lt;property name="c3p0.max_size"&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间,以秒为单位, 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt; &lt;property name="c3p0.timeout"&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt; &lt;property name="c3p0.idle_test_period"&gt;3000&lt;/property&gt; &lt;!-- 设置事务隔离级别 --&gt; &lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; &lt;!-- 配置当前线程绑定的Session --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 引入映射 --&gt; &lt;!-- &lt;mapping resource="com/hibernate/domain/Customer.hbm.xml"/&gt; &lt;mapping resource="com/hibernate/domain/LinkMan.hbm.xml"/&gt; --&gt; &lt;mapping resource="com/hibernate/domain/User.hbm.xml"/&gt; &lt;mapping resource="com/hibernate/domain/Role.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;引入工具类123456789101112131415161718public class HibernateUtils &#123; public static final Configuration cfg; public static final SessionFactory sf; static&#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; public static Session openSession()&#123; return sf.openSession(); &#125; public static Session getCurrentSession()&#123; return sf.getCurrentSession(); &#125;&#125;编写测试类12345678910111213141516171819202122232425262728293031323334353637383940public class HibernateDemo1 &#123; @Test // 保存2个客户 和 3个联系人 并且建立好关系 public void demo1()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建两个客户 Customer customer1 = new Customer(); customer1.setCust_name("王东"); Customer customer2 = new Customer(); customer2.setCust_name("赵洪"); // 创建三个联系人 LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name("凤姐"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name("如花"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name("旺财"); // 设置关系: linkMan1.setCustomer(customer1); linkMan2.setCustomer(customer1); linkMan3.setCustomer(customer2); customer1.getLinkMans().add(linkMan1); customer1.getLinkMans().add(linkMan2); customer2.getLinkMans().add(linkMan3); // 保存数据: session.save(linkMan1); session.save(linkMan2); session.save(linkMan3); session.save(customer1); session.save(customer2); tx.commit(); &#125;&#125;Hibernate 的一对多相关操作一对多关系只保存一边是否可以1234567891011121314151617181920@Test // 一对多关系只保存一边是否可以 public void demo2()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("赵洪"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("如花"); customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); // 只保存一边是否可以：不可以，报一个瞬时对象异常：持久态对象关联了一个瞬时态对象。 // session.save(customer); session.save(linkMan); tx.commit(); &#125;一对多的级联操作什么叫级联级联指的是，操作一个对象的时候，是否会同时操作其关联的对象。级联是有方向性操作一的一方的时候，是否操作到多的一方操作多的一方的时候，是否操作到一的一方级联保存或更新保存客户级联联系人1234567&lt;!-- set标签 ： * name ：多的一方的对象集合的属性名称。 * cascade：级联 * inverse：放弃外键维护权。 --&gt; &lt;set name="linkMans" cascade="save-update" inverse="true"&gt;1234567891011121314151617181920212223@Test /** * 级联保存或更新操作： * * 保存客户级联联系人，操作的主体是客户对象，需要在Customer.hbm.xml中进行配置 * * &lt;set name="linkMans" cascade="save-update"&gt; */ public void demo3()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("赵洪"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("如花"); customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); session.save(customer); tx.commit(); &#125;保存联系人联系人级联客户12345678&lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt; &lt;!-- many-to-one标签 * name :一的一方的对象的属性名称。 * class :一的一方的类的全路径。 * column :在多的一方的表的外键的名称。 --&gt; &lt;many-to-one name="customer" class="com.itheima.hibernate.domain.Customer" column="lkm_cust_id"/&gt;1234567891011121314151617181920212223@Test /** * 级联保存或更新操作： * * 保存联系人级联客户，操作的主体是联系人对象，需要在LinkMan.hbm.xml中进行配置 * * &lt;many-to-one name="customer" cascade="save-update" class="com.itheima.hibernate.domain.Customer" column="lkm_cust_id"/&gt; */ public void demo4()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("李兵"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("凤姐"); customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); session.save(linkMan); tx.commit(); &#125;测试对象的导航123456789101112131415161718192021222324252627282930@Test /** * 测试对象的导航 * * 前提：一对多的双方都设置cascade="save-update" */ public void demo5()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("李兵"); LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name("凤姐"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name("如花"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name("芙蓉"); linkMan1.setCustomer(customer); customer.getLinkMans().add(linkMan2); customer.getLinkMans().add(linkMan3); // 双方都设置了cascade// session.save(linkMan1); // 发送几条insert语句 4条// session.save(customer); // 发送几条insert语句 3条 session.save(linkMan2); // 发送几条insert语句 1条 tx.commit(); &#125;级联删除级联删除：删除一边的时候，同时将另一方的数据也一并删除。删除客户级联删除联系人1234567891011121314151617181920@Test /** * 级联删除： * * 删除客户级联删除联系人，删除的主体是客户，需要在Customer.hbm.xml中配置 * * &lt;set name="linkMans" cascade="delete"&gt; */ public void demo6()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 没有设置级联删除，默认情况:修改了联系人的外键，删除客户 /*Customer customer = session.get(Customer.class, 1l); session.delete(customer);*/ // 删除客户，同时删除联系人 Customer customer = session.get(Customer.class, 1l); session.delete(customer); tx.commit(); &#125;删除联系人级联删除客户（基本不用）12345678910111213141516@Test /** * 级联删除： * * 删除联系人级联删除客户，删除的主体是联系人，需要在LinkMan.hbm.xml中配置 * * &lt;many-to-one name="customer" cascade="delete"&gt; */ public void demo7()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 删除客户，同时删除联系人 LinkMan linkMan = session.get(LinkMan.class, 3l); session.delete(linkMan); tx.commit(); &#125;一对多设置了双向关联产生多余的SQL语句123456789101112131415161718@Test /** * 将2号联系人原来归1号客户，现在改为2号客户 */ public void demo8()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询2号联系人 LinkMan linkMan = session.get(LinkMan.class, 2l); // 查询2号客户 Customer customer = session.get(Customer.class, 2l); // 双向的关联 linkMan.setCustomer(customer); customer.getLinkMans().add(linkMan); tx.commit(); &#125;解决多余的SQL语句单向维护：使一方放弃外键维护权：一的一方放弃。在set上配置inverse=”true”一对多的关联查询的修改的时候。（CRM练习–）区分cascade和inverse12345678910111213141516171819202122@Test /** * 区分cascade和inverse的区别 */ public void demo9()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("李兵"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("凤姐"); customer.getLinkMans().add(linkMan); // 条件在Customer.hbm.xml上的set中配置了cascade="save-update" inverse="true" session.save(customer); // 客户会插入到数据库，联系人也会插入到数据库，但是外键为null tx.commit(); &#125;&#125;Hibernate多对多关系的配置创建表用户表12345678CREATE TABLE `sys_user` ( `user_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '用户id', `user_code` varchar(32) NOT NULL COMMENT '用户账号', `user_name` varchar(64) NOT NULL COMMENT '用户名称', `user_password` varchar(32) NOT NULL COMMENT '用户密码', `user_state` char(1) NOT NULL COMMENT '1:正常,0:暂停', PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;角色表123456CREATE TABLE `sys_role` ( `role_id` bigint(32) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) NOT NULL COMMENT '角色名称', `role_memo` varchar(128) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`role_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;中间表12345678CREATE TABLE `sys_user_role` ( `role_id` bigint(32) NOT NULL COMMENT '角色id', `user_id` bigint(32) NOT NULL COMMENT '用户id', PRIMARY KEY (`role_id`,`user_id`), KEY `FK_user_role_user_id` (`user_id`), CONSTRAINT `FK_user_role_role_id` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`role_id`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `FK_user_role_user_id` FOREIGN KEY (`user_id`) REFERENCES `sys_user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB DEFAULT CHARSET=utf8;创建实体用户的实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; // 设置多对多关系：表示一个用户选择多个角色？ // 放置的是角色的集合 private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); public Long getUser_id() &#123; return user_id; &#125; public void setUser_id(Long user_id) &#123; this.user_id = user_id; &#125; public String getUser_code() &#123; return user_code; &#125; public void setUser_code(String user_code) &#123; this.user_code = user_code; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getUser_password() &#123; return user_password; &#125; public void setUser_password(String user_password) &#123; this.user_password = user_password; &#125; public String getUser_state() &#123; return user_state; &#125; public void setUser_state(String user_state) &#123; this.user_state = user_state; &#125; public Set&lt;Role&gt; getRoles() &#123; return roles; &#125; public void setRoles(Set&lt;Role&gt; roles) &#123; this.roles = roles; &#125; &#125;角色的实体123456789101112131415161718192021222324252627282930313233public class Role &#123; private Long role_id; private String role_name; private String role_memo; // 一个角色被多个用户选择： // 放置的是用户的集合 private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); public Long getRole_id() &#123; return role_id; &#125; public void setRole_id(Long role_id) &#123; this.role_id = role_id; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_memo() &#123; return role_memo; &#125; public void setRole_memo(String role_memo) &#123; this.role_memo = role_memo; &#125; public Set&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(Set&lt;User&gt; users) &#123; this.users = users; &#125; &#125;创建映射用户的映射123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.domain.User" table="sys_user"&gt; &lt;!-- 建立OID与主键的映射 --&gt; &lt;id name="user_id" column="user_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与字段映射 --&gt; &lt;property name="user_code" column="user_code"/&gt; &lt;property name="user_name" column="user_name"/&gt; &lt;property name="user_password" column="user_password"/&gt; &lt;property name="user_state" column="user_state"/&gt; &lt;!-- 建立与角色的多对多的映射关系 --&gt; &lt;!-- set标签 * name ：对方的集合的属性名称。 * table ：多对多的关系需要使用中间表，放的是中间表的名称。 --&gt; &lt;set name="roles" table="sys_user_role" cascade="save-update,delete" &gt; &lt;!-- key标签： * column ：当前的对象对应中间表的外键的名称。 --&gt; &lt;key column="user_id"/&gt; &lt;!-- many-to-many标签： * class ：对方的类的全路径 * column ：对方的对象在中间表中的外键的名称。 --&gt; &lt;many-to-many class="com.hibernate.domain.Role" column="role_id"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;角色的映射12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.domain.Role" table="sys_role"&gt; &lt;!-- 建立OID与主键的映射 --&gt; &lt;id name="role_id" column="role_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 建立普通属性与字段的映射 --&gt; &lt;property name="role_name" column="role_name"/&gt; &lt;property name="role_memo" column="role_memo"/&gt; &lt;!-- 与用户的多对多的映射关系 --&gt; &lt;!-- set标签 * name ：对方的集合的属性名称。 * table ：多对多的关系需要使用中间表，放的是中间表的名称。 --&gt; &lt;set name="users" table="sys_user_role" cascade="save-update,delete" inverse="true"&gt; &lt;!-- key标签： * column ：当前的对象对应中间表的外键的名称。 --&gt; &lt;key column="role_id"/&gt; &lt;!-- many-to-many标签： * class ：对方的类的全路径 * column ：对方的对象在中间表中的外键的名称。 --&gt; &lt;many-to-many class="com.hibernate.domain.User" column="user_id"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;编写测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.itheima.hibernate.demo2;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itheima.hibernate.domain.Role;import com.itheima.hibernate.domain.User;import com.itheima.hibernate.utils.HibernateUtils;/** * Hibernate的多对多的映射 * @author jt * */public class HibernateDemo2 &#123; @Test /** * 保存多条记录：保存多个用户和角色 */ public void demo1()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建2个用户 User user1 = new User(); user1.setUser_name("赵洪"); User user2 = new User(); user2.setUser_name("李兵"); // 创建3个角色 Role role1 = new Role(); role1.setRole_name("研发部"); Role role2 = new Role(); role2.setRole_name("市场部"); Role role3 = new Role(); role3.setRole_name("公关部"); // 设置双向的关联关系: user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role2); user2.getRoles().add(role3); role1.getUsers().add(user1); role2.getUsers().add(user1); role2.getUsers().add(user2); role3.getUsers().add(user2); // 保存操作:多对多建立了双向的关系必须有一方放弃外键维护。 // 一般是被动方放弃外键维护权。 session.save(user1); session.save(user2); session.save(role1); session.save(role2); session.save(role3); tx.commit(); &#125;&#125;Hibernated 多对多的操作只保存一边是否可以1234567891011121314151617181920212223242526@Test /** * 多对多的操作： * * 只保存一边是否可以？不可以，瞬时对象异常 */ public void demo2()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建2个用户 User user1 = new User(); user1.setUser_name("赵洪"); // 创建3个角色 Role role1 = new Role(); role1.setRole_name("研发部"); // 设置双向的关联关系: user1.getRoles().add(role1); role1.getUsers().add(user1); // 只保存用户： // session.save(user1); session.save(role1); tx.commit(); &#125;多对多的级联保存或更新保存用户级联保存角色1234567891011121314151617181920212223242526@Test /** * 多对多的级联保存： * * 保存用户级联保存角色。在用户的映射文件中配置。 * * 在User.hbm.xml中的set上配置 cascade="save-update" */ public void demo3()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建2个用户 User user1 = new User(); user1.setUser_name("赵洪"); // 创建3个角色 Role role1 = new Role(); role1.setRole_name("研发部"); // 设置双向的关联关系: user1.getRoles().add(role1); role1.getUsers().add(user1); // 只保存用户： session.save(user1); tx.commit(); &#125;保存角色级联保存用户1234567891011121314151617181920212223242526/** * 多对多的级联保存： * * 保存角色级联保存用户。在角色的映射文件中配置。 * * 在Role.hbm.xml中的set上配置 cascade="save-update" */ @Test public void demo4()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建2个用户 User user1 = new User(); user1.setUser_name("李兵"); // 创建3个角色 Role role1 = new Role(); role1.setRole_name("公关部"); // 设置双向的关联关系: user1.getRoles().add(role1); role1.getUsers().add(user1); // 只保存用户： session.save(role1); tx.commit(); &#125;多对多的级联删除（基本用不上）删除用户级联删除角色12345678910111213141516/** * 多对多的级联删除： * * 删除用户级联删除角色 * * 在User.hbm.xml中的set上配置 cascade="delete" */ @Test public void demo5()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询1号用户: User user = session.get(User.class, 1l); session.delete(user); tx.commit(); &#125;删除角色级联删除用户12345678910111213141516/** * 多对多的级联删除： * * 删除角色级联删除用户 * * 在Role.hbm.xml中的set上配置 cascade="delete" */ @Test public void demo6()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询2号角色: Role role = session.get(Role.class, 2l); session.delete(role); tx.commit(); &#125;多对多的其他的操作给用户选择角色1234567891011121314151617@Test /** * 给用户选择角色 */ public void demo7()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 给1号用户多选2号角色 // 查询1号用户 User user = session.get(User.class, 1l); // 查询2号角色 Role role = session.get(Role.class, 2l); user.getRoles().add(role); tx.commit(); &#125;给用户改选角色12345678910111213141516171819@Test /** * 给用户改选角色 */ public void demo8()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 给2号用户将原有的2号角色改为3号角色 // 查询2号用户 User user = session.get(User.class, 2l); // 查询2号角色 Role role2 = session.get(Role.class, 2l); Role role3 = session.get(Role.class, 3l); user.getRoles().remove(role2); user.getRoles().add(role3); tx.commit(); &#125;给用户删除角色123456789101112131415161718@Test /** * 给用户改选角色 */ public void demo9()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 给2号用户删除1号角色 // 查询2号用户 User user = session.get(User.class, 2l); // 查询2号角色 Role role = session.get(Role.class, 1l); user.getRoles().remove(role); tx.commit(); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc（简单入门）]]></title>
    <url>%2FSpringMvc%EF%BC%88%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%89.html</url>
    <content type="text"><![CDATA[Spring 入门Springmvc是什么Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来,如下图：Springmvc处理流程如下图所示：入门程序需求：使用浏览器显示商品列表创建web工程springMVC是表现层框架，需要搭建web工程开发。如下图创建动态web工程：输入工程名，选择配置Tomcat（如果已有，则直接使用），如下图：配置Tomcat，如下图：选择准备好的Tomcat，这里用的是Tomcat7，如下图：选择成功，点击Finish，如下图：选择刚刚设置成功的Tomcat，如下图：如下图选择web的版本是2.5，可以自动生成web.xml配置文件，创建效果如下图：导入jar包从课前资料中导入springMVC的jar包，位置如下图：复制jar到lib目录，工程直接加载jar包，如下图：加入配置文件创建config资源文件夹，存放配置文件，如下图：创建springmvc.xml创建SpringMVC的核心配置文件SpringMVC本身就是Spring的子项目，对Spring兼容性很好，不需要做很多配置。这里只配置一个Controller扫描就可以了，让Spring对页面控制层Controller进行管理。创建springmvc.xml12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置controller扫描包 --&gt; &lt;context:component-scan base-package="fun.obey.springmvc.controller" /&gt;&lt;/beans&gt;创建包fun.obey.springmvc.controller配置前端控制器配置SpringMVC的前端控制器DispatcherServlet在web.xml中123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc-first&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置SpringMVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc-first&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定SpringMVC配置文件 --&gt; &lt;!-- SpringMVC的配置文件的默认路径是/WEB-INF/$&#123;servlet-name&#125;-servlet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-first&lt;/servlet-name&gt; &lt;!-- 设置所有以action结尾的请求进入SpringMVC --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;加入jsp页面把写好的itemList.jsp复制到工程的/WEB-INF/jsp目录下，itemList.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/item/queryitem.action" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/toEdit.form?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;实现显示商品列表页创建pojo分析页面，查看页面需要的数据，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package fun.obey.springmvc.pojo;import java.util.Date;public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public Float getPrice() &#123; return price; &#125; public void setPrice(Float price) &#123; this.price = price; &#125; public String getPic() &#123; return pic; &#125; public void setPic(String pic) &#123; this.pic = pic == null ? null : pic.trim(); &#125; public Date getCreatetime() &#123; return createtime; &#125; public void setCreatetime(Date createtime) &#123; this.createtime = createtime; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125;&#125;创建ItemControllerItemController是一个普通的java类，不需要实现任何接口。需要在类上添加@Controller注解，把Controller交由Spring管理在方法上面添加@RequestMapping注解，里面指定请求的url。其中“.action”可以加也可以不加。1234567891011121314151617181920212223242526@Controllerpublic class ItemController &#123; // @RequestMapping：里面放的是请求的url，和用户请求的url进行匹配 // action可以写也可以不写 @RequestMapping("/itemList.action") public ModelAndView queryItemList() &#123; // 创建页面需要显示的商品数据 List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(1, "1华为 荣耀8", 2399, new Date(), "质量好！1")); list.add(new Item(2, "2华为 荣耀8", 2399, new Date(), "质量好！2")); list.add(new Item(3, "3华为 荣耀8", 2399, new Date(), "质量好！3")); list.add(new Item(4, "4华为 荣耀8", 2399, new Date(), "质量好！4")); list.add(new Item(5, "5华为 荣耀8", 2399, new Date(), "质量好！5")); list.add(new Item(6, "6华为 荣耀8", 2399, new Date(), "质量好！6")); // 创建ModelAndView，用来存放数据和视图 ModelAndView modelAndView = new ModelAndView(); // 设置数据到模型中 modelAndView.addObject("list", list); // 设置视图jsp，需要设置视图的物理地址 modelAndView.setViewName("/WEB-INF/jsp/itemList.jsp"); return modelAndView; &#125;&#125;启动项目测试启动项目，浏览器访问地址http://127.0.0.1:8080/springmvc-first/itemList.action效果如下图：为什么可以用呢？我们需要分析一下springMVC的架构图。Springmvc架构框架结构框架结构如下图：架构流程用户发送请求至前端控制器DispatcherServletDispatcherServlet收到请求调用HandlerMapping处理器映射器。处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。DispatcherServlet通过HandlerAdapter处理器适配器调用处理器执行处理器(Controller，也叫后端控制器)。Controller执行完成返回ModelAndViewHandlerAdapter将controller执行结果ModelAndView返回给DispatcherServletDispatcherServlet将ModelAndView传给ViewReslover视图解析器ViewReslover解析后返回具体ViewDispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户组件说明以下组件通常使用框架提供实现：DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。HandlerMapping：处理器映射器HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。下图是许多不同的适配器，最终都可以使用usb接口连接ViewResolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。View：视图springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view默认加载的组件我们没有做任何配置，就可以使用这些组件因为框架已经默认加载这些组件了，配置文件位置如下图：123456789101112131415161718192021222324# Default implementation classes for DispatcherServlet's strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager组件扫描器使用组件扫描器省去在spring容器配置每个Controller类的繁琐。使用&lt;context:component-scan&gt;自动扫描标记@Controller的控制器类，在springmvc.xml配置文件中配置如下：12&lt;!-- 配置controller扫描包，多个包之间用,分隔 --&gt;&lt;context:component-scan base-package="cn.itcast.springmvc.controller" /&gt;注解映射器和适配器配置处理器映射器注解式处理器映射器，对类中标记了@ResquestMapping的方法进行映射。根据@ResquestMapping定义的url匹配@ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器。HandlerMethod对象中封装url对应的方法Method。从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。在springmvc.xml配置文件中配置如下：123&lt;!-- 配置处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping" /&gt;注解描述：@RequestMapping：定义请求url到处理器功能方法的映射配置处理器适配器注解式处理器适配器，对标记@ResquestMapping的方法进行适配。从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。在springmvc.xml配置文件中配置如下：123&lt;!-- 配置处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter" /&gt;注解驱动直接配置处理器映射器和处理器适配器比较麻烦，可以使用注解驱动来加载。SpringMVC使用&lt;mvc:annotation-driven&gt;自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter可以在springmvc.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。12&lt;!-- 注解驱动 --&gt;&lt;mvc:annotation-driven /&gt;视图解析器视图解析器使用SpringMVC框架默认的InternalResourceViewResolver，这个视图解析器支持JSP视图解析在springmvc.xml配置文件中配置如下：12345678910&lt;!-- Example: prefix="/WEB-INF/jsp/", suffix=".jsp", viewname="test" -&gt; "/WEB-INF/jsp/test.jsp" --&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置逻辑视图的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置逻辑视图的后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为ItemList，则最终返回的jsp视图地址:“WEB-INF/jsp/itemList.jsp”最终jsp物理地址：前缀+逻辑视图名+后缀修改ItemController修改ItemController中设置视图的代码12345678910111213141516171819202122232425// @RequestMapping：里面放的是请求的url，和用户请求的url进行匹配// action可以写也可以不写@RequestMapping("/itemList.action")public ModelAndView queryItemList() &#123; // 创建页面需要显示的商品数据 List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(1, "1华为 荣耀8", 2399, new Date(), "质量好！1")); list.add(new Item(2, "2华为 荣耀8", 2399, new Date(), "质量好！2")); list.add(new Item(3, "3华为 荣耀8", 2399, new Date(), "质量好！3")); list.add(new Item(4, "4华为 荣耀8", 2399, new Date(), "质量好！4")); list.add(new Item(5, "5华为 荣耀8", 2399, new Date(), "质量好！5")); list.add(new Item(6, "6华为 荣耀8", 2399, new Date(), "质量好！6")); // 创建ModelAndView，用来存放数据和视图 ModelAndView modelAndView = new ModelAndView(); // 设置数据到模型中 modelAndView.addObject("itemList", list); // 设置视图jsp，需要设置视图的物理地址 // modelAndView.setViewName("/WEB-INF/jsp/itemList.jsp"); // 配置好视图解析器前缀和后缀，这里只需要设置逻辑视图就可以了。 // 视图解析器根据前缀+逻辑视图名+后缀拼接出来物理路径 modelAndView.setViewName("itemList"); return modelAndView;&#125;效果效果和之前一样，如下图：整合mybatis为了更好的学习 springmvc和mybatis整合开发的方法，需要将springmvc和mybatis进行整合。整合目标： 控制层采用springmvc、持久层使用mybatis实现。需要的jar包spring（包括springmvc）mybatismybatis-spring整合包数据库驱动第三方连接池。整合思路Dao层：1、SqlMapConfig.xml，空文件即可，但是需要文件头。2、applicationContext-dao.xmla) 数据库连接池b) SqlSessionFactory对象，需要spring和mybatis整合包下的。c) 配置mapper文件扫描器。Service层：1、applicationContext-service.xml包扫描器，扫描@service注解的类。2、applicationContext-trans.xml配置事务。Controller层：1、Springmvc.xmla) 包扫描器，扫描@Controller注解的类。b) 配置注解驱动c) 配置视图解析器Web.xml文件：1、配置spring2、配置前端控制器。加入jar包复制jar包到/WEB-INF/lib中工程自动加载jar包加入配置文件创建资源文件夹config在其下创建mybatis和spring文件夹，用来存放配置文件.sqlMapConfig.xml使用逆向工程来生成Mapper相关代码，不需要配置别名。在config/mybatis下创建SqlMapConfig.xml1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt;applicationContext-dao.xml配置数据源、配置SqlSessionFactory、mapper扫描器。123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置Mapper扫描包 --&gt; &lt;property name="basePackage" value="cn.itcast.ssm.mapper" /&gt; &lt;/bean&gt;&lt;/beans&gt;db.properties配置数据库相关信息1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springmvc?characterEncoding=utf-8jdbc.username=rootjdbc.password=rootapplicationContext-service.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置service扫描 --&gt; &lt;context:component-scan base-package="cn.itcast.ssm.service" /&gt;&lt;/beans&gt;applicationContext-trans.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.itcast.ssm.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt;springmvc.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置controller扫描包 --&gt; &lt;context:component-scan base-package="cn.itcast.ssm.controller" /&gt; &lt;!-- 注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- Example: prefix="/WEB-INF/jsp/", suffix=".jsp", viewname="test" -&gt; "/WEB-INF/jsp/test.jsp" --&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置逻辑视图的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置逻辑视图的后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt;web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc-web&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置spring --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 使用监听器加载Spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置SrpingMVC的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;!-- 配置所有以action结尾的请求进入SpringMVC --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;加入jsp页面增加itemList.jsp和itemEdit.jsp页面到工程中。结果就这样，基本整合完毕了，现在我们进行一个实战小项目实现商品列表显示需求实现商品查询列表，从mysql数据库查询商品信息。DAO开发使用逆向工程，生成代码，不在描述。ItemService接口12345678910public interface ItemService &#123; /** * 查询商品列表 * * @return */ List&lt;Item&gt; queryItemList();&#125;ItemServiceImpl实现类123456789101112131415@Servicepublic class ItemServiceImpl implements ItemService &#123; @Autowired private ItemMapper itemMapper; @Override public List&lt;Item&gt; queryItemList() &#123; // 从数据库查询商品数据 List&lt;Item&gt; list = this.itemMapper.selectByExample(null); return list; &#125;&#125;ItemController1234567891011121314151617181920212223242526@Controllerpublic class ItemController &#123; @Autowired private ItemService itemService; /** * 显示商品列表 * * @return */ @RequestMapping("/itemList") public ModelAndView queryItemList() &#123; // 获取商品数据 List&lt;Item&gt; list = this.itemService.queryItemList(); ModelAndView modelAndView = new ModelAndView(); // 把商品数据放到模型中 modelAndView.addObject("itemList", list); // 设置逻辑视图 modelAndView.setViewName("itemList"); return modelAndView; &#125;&#125;测试结果如下图]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>SpringMvc</category>
      </categories>
      <tags>
        <tag>SprimgMvc</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap入门]]></title>
    <url>%2FBootStrap%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[什么是BootStrapBootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。 [2]​BootStrap有什么作用能够提高开发人员的工作效率什么是响应式页面适应不同的分辨率显示不同样式,提高用户的体验BootStrap的中文网http://www.bootcss.com下载BootStrapBootStrap结构全局CSSbootStrap中已经定义好了一套CSS的样式表组件BootStrap定义的一套按钮,导航条等组件JS插件BootStrap定义了一套JS的插件,这些插件已经默认实现了很多种效果BootStrap的入门开发引入相关的头文件12345678910&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="../css/bootstrap.css" /&gt;&lt;!--需要引入JQuery--&gt;&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script type="text/javascript" src="../js/bootstrap.js" &gt;&lt;/script&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;BootStrap的布局容器.container 类用于固定宽度并支持响应式布局的容器。123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt;.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt;校验表单扩展:1234567trigger : 触发浏览器默认行为triggerHandler : 不会触发is : 判断find : 查找老黄历:什么json: 轻量级的数据交换格式json对象: {“username”:”zhangsan”}json数组: [ {“username”:”zhangsan”}, {“username”:”zhangsan”}, {“username”:”zhangsan”}]ajax异步请求:​ 同步和异步Bootstrap 栅格系统的工作原理：“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。通过“行（row）”在水平方向创建一组“列（column）”。你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding​BootStrap的栅格系统响应式设计: 这种设计依赖于CSS3中的媒体查询栅格样式:设备分辨率大于1200 使用lg样式设备分辨率大于992 &lt; 1200 使用md样式设备分辨率大于768 &lt; 992 使用sm样式设备分辨率小于768使用xs样式BootStrap的全局CSS定义了一套CSS对页面中的元素进行定义列表元素,表单,按钮,图片…使用BootStrap布局网站首页需求分析请使用BootStrap对我们的首页进行优化技术分析步骤分析新建一个HTML页面.引入bootStrap相关的js和CSS定义一个整体的div, 将整体的div分成8个部分完成没部分的内容显示代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 准备工作: &lt;meta name='viewport'&gt; 1.导入bootstrap css文件 2.导入JQuery 3.bootstrap.js 4.写一个div class = container 支持响应式的布局容器 --&gt; &lt;link rel="stylesheet" href="../css/bootstrap.min.css"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src="../js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4 hidden-xs"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--菜单--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;所有分类 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu" role="menu"&gt; &lt;li&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Separated link&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;One more separated link&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入要搜索的商品"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/div&gt; &lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="../img/1.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/2.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/3.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;img src="../products/hao/ad.jpg" width="100%" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--页脚广告--&gt; &lt;div&gt; &lt;img src="../image/footer.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--网站声明--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="http://www.itheima.com"&gt;关于我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;联系我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;招贤纳士&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;法律声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;友情链接&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;支付方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;配送方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;服务声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;广告声明&lt;/a&gt; &lt;br /&gt; Copyright © 2018-2019 HuiProgramer &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>BootStarp</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery入门]]></title>
    <url>%2FJQuery%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[什么是JQuery:jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等JQuery的作用:写更少的代码,做更多的事情: write Less,Do more将我们页面的JS代码和HTML页面代码进行分离为什么学习JQuery:​ 提高我们的工作效率JQ的入门1234567891011121314151617181920212223242526272829&lt;script&gt; //js文档加载完成的事件 window.onload = function()&#123; alert("window.onload 111"); &#125; window.onload = function()&#123; alert("window.onload 222"); &#125; /*文档加载完成的事件*/ jQuery(document).ready(function()&#123; alert("jQuery(document).ready(function()"); &#125;); /* jQuery 简写成 $ */ $(document).ready(function()&#123; alert("$(document).ready(function()"); &#125;); /* 最简单的写法 */ $(function()&#123; alert("$(function()&#123;"); &#125;); &lt;/script&gt;【JQ中根据ID查找元素】1234全都是根据选择器去找的#ID&#123;&#125;.类名&#123;&#125;$("#ID的名称")【JQ和JS之间的转换】JQ对象,只能调用JQ的属性和方法JS对象 只能调用JS的属性和方法12345678910111213141516171819function changeJS()&#123; var div = document.getElementById("div1");// div.innerHTML = "JS成功修改了内容" //将JS对象转成JQ对象 $(div).html("转成JQ对象来修改内容") &#125; $(function()&#123; //给按钮绑定事件 $("#btn2").click(function()&#123; //找到div1// $("#div1").html("JQ方式成功修改了内容"); //将JQ对象转成JS对象来调用 var $div = $("#div1");// var jsDiv = $div.get(0); var jsDiv = $div[0]; jsDiv.innerHTML="jq转成JS对象成功"; &#125;); &#125;);JQ的开发步骤: (将我们页面的JS代码和HTML页面代码进行分离)导入JQ相关的文件文档加载完成事件: $(function) : 页面初始化的操作: 绑定事件, 启动页面定时器确定相关操作的事件事件触发函数函数里面再去操作相关的元素显示和隐藏 img.style.display【JQ中的动画效果】1234567show()hide()slideUpslideDownfadeInfadeOutanimate : 自定义动画使用JQuery完成页面定时弹出广告需求分析：当用户打开界面，3秒钟之后弹出广告，这个广告显示5秒钟，隐藏广告技术分析定时器: setTimeout显示和隐藏: style.display = “block/none”步骤分析：导入JQ的文件编写JQ的文档加载事件启动定时器 setTimeout(“”,3000);编写显示广告的函数在显示广告里面再启动一个定时器编写隐藏广告的函数代码实现1234567891011121314&lt;script&gt; //显示广告 function showAd()&#123; $("#img1").slideDown(2000); setTimeout("hideAd()",3000); &#125; //隐藏广告 function hideAd()&#123; $("#img1").slideUp(2000); &#125; $(function()&#123; setTimeout("showAd()",3000); &#125;); &lt;/script&gt;JQuery中的选择器让我们能够更加精确找到我们要操作的元素基本选择器ID选择器 : #ID的名称类选择器: 以 . 开头 .类名元素选择器: 标签的名称通配符选择器: *选择器,选择器: 选择器1,选择器2基本选择器的案例12345678910111213141516171819202122232425262728293031323334&lt;!-- - ID选择器 : #ID的名称 - 类选择器: 以 . 开头 .类名 - 元素选择器: 标签的名称 - 通配符选择器: * - 选择器,选择器: 选择器1,选择器2 --&gt; &lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 $("#btn1").click(function()&#123; $("#two").css("background-color","palegreen"); &#125;); //找出mini类的所有元素 $("#btn2").click(function()&#123; $(".mini").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("*").css("background-color","palegreen"); &#125;); /*选择器分组*/ //找出mini类 和 span元素 $("#btn5").click(function()&#123; $(".mini,span").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt;JQ中的层级选择器子元素选择器: 选择器1 &gt; 选择器2后代选择器: 选择器1 儿孙相邻兄弟选择器 : 选择器1 + 选择器2 : 找出紧挨着的一个弟弟找出所有弟弟: 选择器1~ 选择器2 : 找出所有的弟弟123456789101112131415161718192021&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //找出body下面的子div $("#btn1").click(function()&#123; $("body &gt; div").css("background-color","palegreen"); &#125;); //找出body下面的所有div $("#btn2").click(function()&#123; $("body div").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("#one+div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("#two~div").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt;JQ中的基本过滤器12345678910111213141516171819202122232425&lt;script&gt; $(function()&#123; /&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //过滤出所有div中第一个元素 $("#btn1").click(function()&#123; $("div:first").css("background-color","palegreen"); &#125;); //过滤出所有div中偶数位的div $("#btn2").click(function()&#123; $("div:even").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div:odd").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("div:gt(2)").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt;JQ中的属性选择器123456789101112$(function()&#123; //找到有name属性的input $("#btn1").click(function()&#123; $("input[name]").attr("checked",true); &#125;); $("#btn2").click(function()&#123; $("input[name='accept']").attr("checked",true); &#125;); $("#btn3").click(function()&#123; $("input[name='newsletter'][value='Hot Fuzz']").attr("checked",true); &#125;); &#125;);JQ中的表单过滤器123456&lt;script&gt; //1.文档加载事件 $(function()&#123; $(":text").css("background-color","pink"); &#125;);&lt;/script&gt;使用JQ完成表格的隔行换色需求分析:在我们的实际开发过程中,我们的表格如果所有的行都是一样的话,很容易看花眼,所以我们需要让我们的表格隔行换色技术分析:获取所有行 table.rows遍历所有行根据行号去修改每一行的背景颜色: bgColor​ style.backgroundColor = “red”步骤分析:导入JQ的包文档加载完成函数: 页面初始化获得所有的行 : 元素选择器根据行号去修改颜色代码实现:123456789 $(function()&#123; //获得所有的行 : 元素选择器 $("tbody &gt; tr:even").css("background-color","#CCCCCC"); //修改基数行 $("tbody &gt; tr:odd").css("background-color","#FFF38F");// $("tbody &gt; tr").css("background-color","#FFF38F"); &#125;);使用JQuery完成表单的全选全不选功能需求分析​ 在我们对表格处理的时,有些情况下,我们需要对表格进行批量处理,技术分析:代码实现:使用JQ完成省市联动效果需求分析:​ 在我们的注册表单中,通常我们需要知道用户的籍贯,需要一个给用选择的项,当用户选中了省份之后,列出省下面所有的城市技术分析:准备工作 : 城市信息的数据添加节点 : appendChild (JS)append : 添加子元素到末尾appendTo : 给自己找一个爹,将自己添加到别人家里prepend : 在子元素前面添加after : 在自己的后面添加一个兄弟遍历的操作:​步骤分析:导入JQ的文件文档加载事件:页面初始化进一步确定事件: change事件函数: 得到当前选中省份得到城市, 遍历城市数据将遍历出来的城市添加到城市的select中代码实现:123456789101112131415161718$(function()&#123; $("#province").change(function()&#123;// alert(this.value); //得到城市信息 var cities = provinces[this.value]; //清空城市select中的option /*var $city = $("#city"); //将JQ对象转成JS对象 var citySelect = $city.get(0) citySelect.options.length = 0;*/ $("#city").empty(); //采用JQ的方式清空 //遍历城市数据 $(cities).each(function(i,n)&#123; $("#city").append("&lt;option&gt;"+n+"&lt;/option&gt;"); &#125;); &#125;); &#125;);使用JQ完成下拉列表左右选择需求分析我们的商品通常包含已经有了的, 还有没有的,现在我们需要有一个页面用于动态编辑这些商品技术分析步骤分析导入JQ的文件文档加载函数 :页面初始化确定事件 : 点击事件 onclick事件触发函数移动被选中的那一项到右边代码实现12345678910111213141516&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("#a1").click(function()&#123; //找到被选中的那一项 //将被选中项添加到右边 $("#rightSelect").append($("#leftSelect option:selected")); &#125;); //将左边所有商品移动到右边 $("#a2").click(function()&#123; $("#rightSelect").append($("#leftSelect option")); &#125;); &#125;);&lt;/script&gt;总结:定时器动画效果: show hide slideDown slideUp fadeIn fadeOut animate基本选择器:ID选择器: #ID名称类选择器: .类名元素选择器: 元素/标签名称通配符选择器: * 找出所有页面元素 包含页面上所有的标签选择器分组 : 选择器1, 选择器2 [选择器1,选择器2]层级选择器:后代选择器: 选择器1 选择器2 找出所有的后代,儿子孙子曾孙子元素选择器: 选择器1 &gt;选择器2 找出所有儿子相邻兄弟选择器: 选择器1+选择器2 : 找出紧挨着自己那个弟弟兄弟选择器 : 选择器1~选择器2 : 找出所有的弟弟​​​属性选择器:选择器[属性名称]​12选择器[属性名称][属性名名]选择器[属性名称='属性值'][属性名称='属性值'][属性名称='属性值']表单选择器:123456​ :input 找出所有的输入项 : 不单单找出input textarea select ​ :text 找出type类型为 text​ :password基本过滤器:12345678910111213​ :even​ :odd​ :gt​ :lt​ :eq​ :first​ :last表单对象属性:123​ :selected​ :checked12345678910111213141516171819202122$(function) : 文档加载完成的事件css() : 修改css样式prop() : 修改属性/ 获取属性html() : 修改innerHTMLappend : 给自己添加子节点appendTo : 将自己添加到别人家,给自己找一个爹prepend : 在自己最前面添加子节点after : 在自己后面添加一个兄弟empty : 清空所有子节点$(cities).each(function(i,n)&#123; &#125;)$.each(arr,function(i,n)&#123; &#125;);了解, 熟悉, 熟练, 精通 经过一个项目,将所有学过串起来使用JQ完成表单的校验(扩展)需求分析在用户提交表单的时候, 我们最好是能够在用户数据提交给服务器之前去做一次校验,防止服务器压力过大,并且需要给用户一个友好提示技术分析triggertriggerHandleris()步骤分析首先给必填项,添加尾部添加一个小红点获取用户输入的信息,做相应的校验事件: 获得焦点, 失去焦点, 按键抬起表单提交的事件代码实现使用JQuery发送请求局部刷新页面​ 数据交换格式:​ json​ xml​什么是JSONJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。JSON格式​ JSON对象12&#123; key1:value&#125; &#123;"username":"zhangsan","password":"123"&#125;​ JSON数组1[&#123; key1:value&#125;,&#123; key1:value&#125;,&#123; key1:value&#125;]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis教程（简单入门）]]></title>
    <url>%2FMybatis-%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[Mybatis入门Mybatis的介绍MyBatis 本是 apache 的一个开源项目 iBatis, 2010年这个项目由apache software foundation 迁移到了 google code，并且改名为MyBatis 。2013年11月迁移到 Github。MyBatis是一个优秀的持久层框架，它对 jdbc 的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等 jdbc 繁杂的过程代码。Mybatis 通过 xml 或注解的方式将要执行的各种 statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和 statement 中的sql进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射成 java 对象并返回。使用jdbc编程问题总结创建mysql数据库创建数据库将sql脚本文件导入到数据库中创建工程开发环境IDE: Intellij IDEAJDK: 1.9创建一个Java工程按下图进行创建导入需要的数据库驱动在 file -&gt; project Setting -&gt; Moudules -&gt; Dependencies里，添加jar文件。jdbc编程步骤加载数据库驱动创建并获取数据库链接创建jdbc statement对象设置sql语句设置sql语句中的参数(使用preparedStatement)通过statement执行sql并获取结果对sql执行结果进行解析处理释放资源(resultSet、preparedstatement、connection)jdbc程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; // 加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); // 通过驱动管理类获取数据库链接 connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "root"); // 定义sql语句 ?表示占位符 String sql = "select * from user where username = ?"; // 获取预处理statement preparedStatement = connection.prepareStatement(sql);// 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, "王五"); // 向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); // 遍历查询结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString("id") + " " + resultSet.getString("username")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。jdbc问题总结如下数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。Mybatis架构mybatis配置SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。Mybatis入门程序mybatis下载mybaits的代码由github.com管理下载地址：https://github.com/mybatis/mybatis-3/releasesmybatis-3.2.7.jar &emsp;——-》&emsp;mybatis的核心包lib文件夹 &emsp;&nbsp;&emsp;&emsp;&emsp;&nbsp;——-》&emsp;mybatis的依赖包所在mybatis-3.2.7.pdf&emsp; ——-》&emsp;mybatis使用手册业务需求使用MyBatis实现以下功能：根据用户id查询一个用户根据用户名称模糊查询用户列表添加用户更新用户删除用户环境搭建创建Java工程这个前面讲过，直接省略。。。加入jar包加入mybatis核心包、依赖包、数据驱动包。mybatis核心包mybatis依赖包数据库驱动包效果：加入配置文件在src文件夹下，加入log4j.properties和SqlMapConfig.xml配置文件log4j.properties在 src 下创建log4j.properties如下：123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n注意：mybatis默认使用log4j作为输出日志信息。SqlMapConfig.XML在 src 下创建SqlMapConfig.xml，如下：123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt;注意：SqlMapConfig.xml是mybatis核心配置文件，配置文件内容为数据源、事务管理。效果：创建pojopojo类作为mybatis进行sql映射使用，po类通常与数据库表对应，数据库如下所示：123456789DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` date DEFAULT NULL COMMENT '生日', `sex` char(1) DEFAULT NULL COMMENT '性别', `address` varchar(256) DEFAULT NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;User.java如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.share.mybatis.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", sex=" + sex + ", birthday=" + birthday + ", address=" + address + "]"; &#125;&#125;sql映射文件User.xml:1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;mapper namespace="test"&gt;&lt;/mapper&gt;加载映射文件mybatis框架需要加载Mapper.xml映射文件将users.xml添加在SqlMapConfig.xml，如下：1234&lt;!-- Mapper位置 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;根据id查询用户使用的sql:SELECT * FROM &#39;user&#39; WHERE id = 1映射文件在user.xml中添加select标签，编写sql：1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;mapper namespace="test"&gt; &lt;!-- id:statement的id 或者叫做sql的id--&gt; &lt;!-- parameterType:声明输入参数的类型 --&gt; &lt;!-- resultType:声明输出结果的类型，应该填写pojo的全路径 --&gt; &lt;!-- #&#123;&#125;：输入参数的占位符，相当于jdbc的？ --&gt; &lt;select id="queryUserById" parameterType="int" resultType="cn.itcast.mybatis.pojo.User"&gt; SELECT * FROM `user` WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;测试程序：测试程序步骤：创建SqlSessionFactoryBuilder对象加载SqlMapConfig.xml配置文件创建SqlSessionFactory对象创建SqlSession对象执行SqlSession对象执行查询，获取结果User打印结果释放资源MybatisTest编写测试程序如下：12345678910111213141516171819202122232425262728293031public class MybatisTest &#123; private SqlSessionFactory sqlSessionFactory = null; @Before public void init() throws Exception &#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 3. 创建SqlSessionFactory对象 this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() throws Exception &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User // 第一个参数是User.xml的statement的id，第二个参数是执行sql需要的参数； Object user = sqlSession.selectOne("queryUserById", 1); // 6. 打印结果 System.out.println(user); // 7. 释放资源 sqlSession.close(); &#125;&#125;效果DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 1077072774.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@4032d386]DEBUG [main] - ==&gt; Preparing: select * from user where id = ?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=王五, sex=2, birthday=null, address=null]实现根据用户名模糊查询用户查询sql：SELECT * FROM &#39;user&#39; WHERE username LIKE &#39;%王%&#39;方法一映射文件在User.xml配置文件中添加如下内容：123456 &lt;!-- 如果返回多个结果，mybatis会自动把返回的结果放在list容器中 --&gt;&lt;!-- resultType的配置和返回一个结果的配置一样 --&gt;&lt;select id="queryUserByUsername1" parameterType="string" resultType="cn.itcast.mybatis.pojo.User"&gt; SELECT * FROM `user` WHERE username LIKE #&#123;username&#125;&lt;/select&gt;测试程序MybatisTest中添加测试方法如下：1234567891011121314151617 @Testpublic void testQueryUserByUsername1() throws Exception &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User // 查询多条数据使用selectList方法 List&lt;Object&gt; list = sqlSession.selectList("queryUserByUsername1", "%王%"); // 6. 打印结果 for (Object user : list) &#123; System.out.println(user); &#125; // 7. 释放资源 sqlSession.close();&#125;结果DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 554868511.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@21129f1f]DEBUG [main] - ==&gt; Preparing: select * from user where username like &#39;%%五%&#39;DEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 2User [id=1, username=王五, sex=2, birthday=null, address=null]User [id=26, username=王五, sex=null, birthday=null, address=null]方法二映射文件：在User.xml配置文件中添加如下内容：12345&lt;!-- 如果传入的参数是简单数据类型，$&#123;&#125;里面必须写value --&gt;&lt;select id="queryUserByUsername2" parameterType="string" resultType="cn.itcast.mybatis.pojo.User"&gt; SELECT * FROM `user` WHERE username LIKE '%$&#123;value&#125;%'&lt;/select&gt;测试程序：MybatisTest中添加测试方法如下：1234567891011121314151617@Testpublic void testQueryUserByUsername2() throws Exception &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User // 查询多条数据使用selectList方法 List&lt;Object&gt; list = sqlSession.selectList("queryUserByUsername2", "王"); // 6. 打印结果 for (Object user : list) &#123; System.out.println(user); &#125; // 7. 释放资源 sqlSession.close();&#125;效果DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 554868511.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@21129f1f]DEBUG [main] - ==&gt; Preparing: select * from user where username like &#39;%%五%&#39;DEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 2User [id=1, username=王五, sex=2, birthday=null, address=null]User [id=26, username=王五, sex=null, birthday=null, address=null]小结#{}和${}#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。parameterType和resultTypeparameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中selectOne和selectListselectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：12org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)selectList可以查询一条或多条记录。实现添加用户使用的sql：INSERT INTO &#39;user&#39; (username,birthday,sex,address) VALUES (&#39;黄忠&#39;,&#39;2016-07-26&#39;,&#39;1&#39;,&#39;三国&#39;)映射文件：在User.xml配置文件中添加如下内容：123456&lt;!-- 保存用户 --&gt;&lt;insert id="saveUser" parameterType="cn.itcast.mybatis.pojo.User"&gt; INSERT INTO `user` (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;测试程序MybatisTest中添加测试方法如下：12345678910111213141516171819202122@Testpublic void testSaveUser() &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行保存 // 创建需要保存的User User user = new User(); user.setUsername("张飞"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("蜀国"); sqlSession.insert("saveUser", user); System.out.println(user); // 需要进行事务提交 sqlSession.commit(); // 7. 释放资源 sqlSession.close();&#125;效果123456789DEBUG [main] - Created connection 1550228904.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@5c669da8]DEBUG [main] - ==&gt; Preparing: insert into user(username,birthday,address,sex) values(?,?,?,?) DEBUG [main] - ==&gt; Parameters: 张飞(String), 2019-03-26 19:20:25.336(Timestamp), 蜀国(String), 1(String)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - ==&gt; Preparing: select LAST_INSERT_ID() DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 1User [id=0, username=张飞, sex=1, birthday=Tue Mar 26 19:20:25 CST 2019, address=蜀国]如上所示，保存成功，但是id=0，需要解决id返回不正常的问题。mysql自增主键返回查询id的sqlSELECT LAST_INSERT_ID()通过修改User.xml映射文件，可以将mysql自增主键返回：如下添加selectKey 标签123456789101112131415&lt;!-- 保存用户 --&gt;&lt;insert id="saveUser" parameterType="cn.itcast.mybatis.pojo.User"&gt; &lt;!-- selectKey 标签实现主键返回 --&gt; &lt;!-- keyColumn:主键对应的表中的哪一列 --&gt; &lt;!-- keyProperty：主键对应的pojo中的哪一个属性 --&gt; &lt;!-- order：设置在执行insert语句前执行查询id的sql，孩纸在执行insert语句之后执行查询id的sql --&gt; &lt;!-- resultType：设置返回的id的类型 --&gt; &lt;selectKey keyColumn="id" keyProperty="id" order="AFTER" resultType="int"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO `user` (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;LAST_INSERT_ID() : 是mysql的函数，返回auto_increment自增列新记录id值。效果:123456789DEBUG [main] - Created connection 1550228904.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@5c669da8]DEBUG [main] - ==&gt; Preparing: insert into user(username,birthday,address,sex) values(?,?,?,?) DEBUG [main] - ==&gt; Parameters: 张飞(String), 2019-03-26 19:20:25.336(Timestamp), 蜀国(String), 1(String)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - ==&gt; Preparing: select LAST_INSERT_ID() DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 1User [id=29, username=张飞, sex=1, birthday=Tue Mar 26 19:20:25 CST 2019, address=蜀国]Mysql使用 uuid实现主键需要增加通过select uuid()得到uuid值123456789101112131415&lt;!-- 保存用户 --&gt;&lt;insert id="saveUser" parameterType="cn.itcast.mybatis.pojo.User"&gt; &lt;!-- selectKey 标签实现主键返回 --&gt; &lt;!-- keyColumn:主键对应的表中的哪一列 --&gt; &lt;!-- keyProperty：主键对应的pojo中的哪一个属性 --&gt; &lt;!-- order：设置在执行insert语句前执行查询id的sql，孩纸在执行insert语句之后执行查询id的sql --&gt; &lt;!-- resultType：设置返回的id的类型 --&gt; &lt;selectKey keyColumn="id" keyProperty="id" order="BEFORE" resultType="string"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO `user` (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;注意: 这里使用的order是“BEFORE”修改用户根据用户id修改用户名使用的sql：UPDATE &#39;user&#39; SET username = &#39;赵云&#39; WHERE id = 26映射文件在User.xml配置文件中添加如下内容：12345&lt;!-- 更新用户 --&gt;&lt;update id="updateUserById" parameterType="cn.itcast.mybatis.pojo.User"&gt; UPDATE `user` SET username = #&#123;username&#125; WHERE id = #&#123;id&#125;&lt;/update&gt;测试程序MybatisTest中添加测试方法如下：12345678910111213141516171819202122@Testpublic void testUpdateUserById() &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行更新 // 创建需要更新的User User user = new User(); user.setId(26); user.setUsername("关羽"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("蜀国"); sqlSession.update("updateUserById", user); // 需要进行事务提交 sqlSession.commit(); // 7. 释放资源 sqlSession.close();&#125;效果123456DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 684822005.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@28d18df5]DEBUG [main] - ==&gt; Preparing: update user set username = ?,sex = ?,address = ?,birthday=? where id = ? DEBUG [main] - ==&gt; Parameters: 关羽(String), 1(String), 蜀国(String), 2019-03-26 19:50:34.234(Timestamp), 26(Integer)DEBUG [main] - &lt;== Updates: 1删除用户根据用户id删除用户使用的sqlDELETE FROM &#39;user&#39; WHERE id = 47映射文件：在User.xml配置文件中添加如下内容：12345&lt;!-- 删除用户 --&gt;&lt;delete id="deleteUserById" parameterType="int"&gt; delete from user where id=#&#123;id&#125;&lt;/delete&gt;测试程序：MybatisTest中添加测试方法如下：1234567891011121314@Testpublic void testDeleteUserById() &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行删除 sqlSession.delete("deleteUserById", 48); // 需要进行事务提交 sqlSession.commit(); // 7. 释放资源 sqlSession.close();&#125;效果123456DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 684822005.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@28d18df5]DEBUG [main] - ==&gt; Preparing: delete from user where id = ? DEBUG [main] - ==&gt; Parameters: 26(Integer)DEBUG [main] - &lt;== Updates: 1Mybatis解决jdbc编程的问题数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。mybatis与hibernate不同Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。Dao开发方法使用MyBatis开发Dao，通常有两个方法，即原始Dao开发方法和Mapper动态代理开发方法。需求使用MyBatis开发DAO实现以下的功能：根据用户id查询一个用户信息根据用户名称模糊查询用户信息列表添加用户信息SqlSession的使用范围SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。SqlSession通过SqlSessionFactory创建。SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。SqlSessionFactoryBuilderSqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory创建的。所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。SqlSessionFactorySqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。SqlSessionSqlSession是一个面向用户的接口，sqlSession中定义了数据库操作方法。每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下：123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125;原始Dao开发方式原始Dao开发方法需要程序员编写Dao接口和Dao实现类。映射文件编写映射文件如下：（也可以使用入门程序完成的映射文件）1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面会讲 --&gt;&lt;mapper namespace="test"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id="queryUserById" parameterType="int" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 根据username模糊查询用户 --&gt; &lt;select id="queryUserByUsername" parameterType="string" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 保存用户 --&gt; &lt;insert id="saveUser" parameterType="cn.itcast.mybatis.pojo.User"&gt; &lt;selectKey keyProperty="id" keyColumn="id" order="AFTER" resultType="int"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt;Dao接口先进行DAO的接口开发，编码如下：123456789101112131415161718192021222324public interface UserDao &#123; /** * 根据id查询用户 * * @param id * @return */ User queryUserById(int id); /** * 根据用户名模糊查询用户 * * @param username * @return */ List&lt;User&gt; queryUserByUsername(String username); /** * 保存用户 * * @param user */ void saveUser(User user);&#125;Dao实现类编写的Dao实现类如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; super(); this.sqlSessionFactory = sqlSessionFactory; &#125; @Override public User queryUserById(int id) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行查询逻辑 User user = sqlSession.selectOne("queryUserById", id); // 释放资源 sqlSession.close(); return user; &#125; @Override public List&lt;User&gt; queryUserByUsername(String username) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行查询逻辑 List&lt;User&gt; list = sqlSession.selectList("queryUserByUsername", username); // 释放资源 sqlSession.close(); return list; &#125; @Override public void saveUser(User user) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行保存逻辑 sqlSession.insert("saveUser", user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); &#125;&#125;Dao测试创建一个JUnit的测试类，对UserDao进行测试，测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UserDaoTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; // 创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 创建SqlsessionFactory this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 执行查询 User user = userDao.queryUserById(1); System.out.println(user); &#125; @Test public void testQueryUserByUsername() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 执行查询 List&lt;User&gt; list = userDao.queryUserByUsername("张"); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test public void testSaveUser() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 创建保存对象 User user = new User(); user.setUsername("刘备"); user.setBirthday(new Date()); user.setSex("1"); user.setAddress("蜀国"); // 执行保存 userDao.saveUser(user); System.out.println(user); &#125;&#125;问题原始Dao开发中存在以下问题：Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不得于开发维护。Mapper动态代理方式开发规范Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。Mapper接口开发需要遵循以下规范：Mapper.xml文件中的namespace与mapper接口的类路径相同。Mapper接口方法名和Mapper.xml中定义的每个statement的id相同Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同Mapper.xml(映射文件)定义mapper映射文件UserMapper.xml将UserMapper.xml放在src下sqlmap目录下UserMapper.xml配置文件内容：123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;!-- 还有一个很重要的作用，使用动态代理开发DAO，1. namespace必须和Mapper接口类路径一致 --&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.UserMapper"&gt; &lt;!-- 根据用户id查询用户 --&gt; &lt;!-- 2. id必须和Mapper接口方法名一致 --&gt; &lt;!-- 3. parameterType必须和接口方法参数类型一致 --&gt; &lt;!-- 4. resultType必须和接口方法返回值类型一致 --&gt; &lt;select id="queryUserById" parameterType="int" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名查询用户 --&gt; &lt;select id="queryUserByUsername" parameterType="string" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 保存用户 --&gt; &lt;insert id="saveUser" parameterType="cn.itcast.mybatis.pojo.User"&gt; &lt;selectKey keyProperty="id" keyColumn="id" order="AFTER" resultType="int"&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;); &lt;/insert&gt;&lt;/mapper&gt;UserMapper(接口文件)创建UserMapper接口代码如下：123456789101112131415161718192021222324public interface UserMapper &#123; /** * 根据id查询 * * @param id * @return */ User queryUserById(int id); /** * 根据用户名查询用户 * * @param username * @return */ List&lt;User&gt; queryUserByUsername(String username); /** * 保存用户 * * @param user */ void saveUser(User user);&#125;加载UserMapper.xml文件修改SqlMapConfig.xml文件，添加以下所示的内容：12345&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;mapper resource="mapper/UserMapper.xml" /&gt;&lt;/mappers&gt;测试编写的测试方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; // 创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 创建SqlsessionFactory this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 执行查询方法 User user = userMapper.queryUserById(1); System.out.println(user); // 和spring整合后由spring管理 sqlSession.close(); &#125; @Test public void testQueryUserByUsername() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 执行查询方法 List&lt;User&gt; list = userMapper.queryUserByUsername("张"); for (User user : list) &#123; System.out.println(user); &#125; // 和spring整合后由spring管理 sqlSession.close(); &#125; @Test public void testSaveUser() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 创建保存对象 User user = new User(); user.setUsername("刘备"); user.setBirthday(new Date()); user.setSex("1"); user.setAddress("蜀国"); // 执行查询方法 userMapper.saveUser(user); System.out.println(user); // 和spring整合后由spring管理 sqlSession.commit(); sqlSession.close(); &#125;&#125;小结selectOne和selectList动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。namespacemybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。SqlMapConfig.xml配置文件配置内容SqlMapConfig.xml中配置的内容和顺序如下：properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象）environment（环境子属性对象）transactionManager（事务管理）dataSource（数据源）mappers（映射器）properties（属性）SqlMapConfig.xml可以引用java属性文件中的配置信息如下：在config下定义jdbc.properties文件，如下所示：jdbc.properties配置文件内容如下:1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=rootSqlMapConfig.xml引用如下：12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 是用resource属性加载外部配置文件 --&gt; &lt;properties resource="db.properties"&gt; &lt;!-- 在properties内部用property定义属性 --&gt; &lt;!-- 如果外部配置文件有该属性，则内部定义属性被外部属性覆盖 --&gt; &lt;property name="jdbc.username" value="root123" /&gt; &lt;property name="jdbc.password" value="root123" /&gt; &lt;/properties&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;mapper resource="mapper/UserMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt;注意： MyBatis 将按照下面的顺序来加载属性：在 properties 元素体内定义的属性首先被读取。然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。typeAliases（类型别名）mybatis支持别名：别名映射的类型_bytebyte_longlong_shortshort_intint_integerint_doubledouble_floatfloat_booleanbooleanstringStringbyteBytelongLongshortShortintIntegerintegerIntegerdoubleDoublefloatFloatbooleanBooleandateDatedecimalBigDecimalbigdecimalBigDecimalmapMap自定义别名：在SqlMapConfig.xml中配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 是用resource属性加载外部配置文件 --&gt; &lt;properties resource="db.properties"&gt; &lt;!-- 在properties内部用property定义属性 --&gt; &lt;property name="jdbc.username" value="root123" /&gt; &lt;property name="jdbc.password" value="root123" /&gt; &lt;/properties&gt; &lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="user" type="cn.itcast.mybatis.pojo.User" /&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感） --&gt; &lt;package name="cn.itcast.mybatis.pojo" /&gt; &lt;package name="其它包" /&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;mapper resource="mapper/UserMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt;在mapper.xml配置文件中，就可以使用设置的别名了提示：别名大小写不敏感mappers（映射器）Mapper配置的几种方法：&lt;mapper resource=” “ /&gt;使用相对于类路径的资源（现在的使用方式）如：&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;&lt;mapper class=” “ /&gt;使用mapper接口类路径如：&lt;mapper class=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt;注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。&lt;package name=””/&gt;注册指定包下的所有mapper接口如：&lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt;注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。Mybatis进阶parameterType(输入类型)传递简单类型参考入门的内容。使用#{}占位符，或者${}进行sql拼接。传递pojo对象参考入门的内容。Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。传递pojo包装对象开发中通过可以使用pojo传递查询条件。查询条件可能是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如查询用户信息的时候，将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。包装对象：Pojo类中的一个属性是另外一个pojo。需求：根据用户名模糊查询用户信息，查询条件放到QueryVo的user属性中。编写QueryVo1234567891011public class QueryVo &#123; // 包含其他的pojo private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125;Sql语句SELECT * FROM user WHERE username LIKE &#39;%张%&#39;Mapper.xml文件123&lt;select id="queryUserByQueryVo" parameterType="queryVo" resultType="user"&gt; select * from user where username like '%$&#123;user.username&#125;%' &lt;/select&gt;Mapper接口List&lt;User&gt; queryUserByQueryVo(Query queryVo);测试方法在UserMapeprTest增加测试方法，如下：123456789101112131415161718192021222324@Testpublic void testQueryUserByQueryVo() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行查询，使用包装对象 QueryVo queryVo = new QueryVo(); // 设置user条件 User user = new User(); user.setUsername("张"); // 设置到包装对象中 queryVo.setUser(user); // 执行查询 List&lt;User&gt; list = userMapper.queryUserByQueryVo(queryVo); for (User u : list) &#123; System.out.println(u); &#125; // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果123456DEBUG [main] - ==&gt; Preparing: select * from user where username like &apos;%%张%&apos; DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 3User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市]User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州]User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州]resultType(输出类型)输出简单类型需求:查询用户表数据条数sql：SELECT count(*) FROM userMapper.xml文件123&lt;select id = "queryUserCount" resultType = "int"&gt; select count(*) from 'user'&lt;/select&gt;Mapper接口int queryUserCount();测试方法在UserMapeprTest增加测试方法，如下：1234567891011121314@Testpublic void testQueryUserCount() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行查询用户数据条数 int count = userMapper.queryUserCount(); System.out.println(count); // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果1234DEBUG [main] - ==&gt; Preparing: select count(*) from &apos;user&apos;DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 114注意：输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。resultMapresultType可以指定将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。需求：查询订单表order的所有数据sql：SELECT id, user_id, number, createtime, note FROM order声明pojo对象数据库如下：1234567891011DROP TABLE IF EXISTS `orders`;CREATE TABLE `orders` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL COMMENT '下单用户id', `number` varchar(32) NOT NULL COMMENT '订单号', `createtime` datetime NOT NULL COMMENT '创建订单时间', `note` varchar(100) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`), KEY `FK_orders_1` (`user_id`), CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;Order对象：12345678910111213public class Order &#123; // 订单id private int id; // 用户id private Integer userId; // 订单号 private String number; // 订单创建时间 private Date createtime; // 备注 private String note;get/set。。。&#125;Mapper.xml文件创建OrderMapper.xml配置文件，如下：12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，Mapper动态代理开发的时候使用，需要指定Mapper的类路径 --&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.OrderMapper"&gt; &lt;!-- 查询所有的订单数据 --&gt; &lt;select id="queryOrderAll" resultType="order"&gt; SELECT id, user_id, number, createtime, note FROM `order` &lt;/select&gt;&lt;/mapper&gt;Mapper接口编写接口如下：12345678public interface OrderMapper &#123; /** * 查询所有订单 * * @return */ List&lt;Order&gt; queryOrderAll();&#125;测试方法编写测试方法OrderMapperTest如下：1234567891011121314151617181920212223public class OrderMapperTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testQueryAll() &#123; // 获取sqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 获取OrderMapper OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); // 执行查询 List&lt;Order&gt; list = orderMapper.queryOrderAll(); for (Order order : list) &#123; System.out.println(order); &#125; &#125;&#125;效果123456DEBUG [main] - ==&gt; Preparing: select id,user_id,number,createtime,not from &apos;order&apos;DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 3Order[id = 3,userId=null,number=1000010,createtime=Wed Feb 04 13:22:35 CST 2015,note = null]Order[id = 4,userId=null,number=1000011,createtime=Wed Feb 04 13:22:35 CST 2015,note = null]Order[id = 5,userId=null,number=1000012,createtime=Wed Feb 04 13:22:35 CST 2015,note = null]发现userId为null解决方案：使用resultMap使用resultMap由于上边的mapper.xml中sql查询列(user_id)和Order类属性(userId)不一致，所以查询结果不能映射到pojo中。需要定义resultMap，把orderResultMap将sql查询列(user_id)和Order类属性(userId)对应起来改造OrderMapper.xml，如下：123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，Mapper动态代理开发的时候使用，需要指定Mapper的类路径 --&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.OrderMapper"&gt; &lt;!-- resultMap最终还是要将结果映射到pojo上，type就是指定映射到哪一个pojo --&gt; &lt;!-- id：设置ResultMap的id --&gt; &lt;resultMap type="order" id="orderResultMap"&gt; &lt;!-- 定义主键 ,非常重要。如果是多个字段,则定义多个id --&gt; &lt;!-- property：主键在pojo中的属性名 --&gt; &lt;!-- column：主键在数据库中的列名 --&gt; &lt;id property="id" column="id" /&gt; &lt;!-- 定义普通属性 --&gt; &lt;result property="userId" column="user_id" /&gt; &lt;result property="number" column="number" /&gt; &lt;result property="createtime" column="createtime" /&gt; &lt;result property="note" column="note" /&gt; &lt;/resultMap&gt; &lt;!-- 查询所有的订单数据 --&gt; &lt;select id="queryOrderAll" resultMap="orderResultMap"&gt; SELECT id, user_id, number, createtime, note FROM `order` &lt;/select&gt;&lt;/mapper&gt;效果只需要修改Mapper.xml就可以了，再次测试结果如下：123456DEBUG [main] - ==&gt; Preparing: select id,user_id,number,createtime,not from &apos;order&apos;DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 3Order[id = 3,userId=1,number=1000010,createtime=Wed Feb 04 13:22:35 CST 2015,note = null]Order[id = 4,userId=1,number=1000011,createtime=Wed Feb 04 13:22:35 CST 2015,note = null]Order[id = 5,userId=10,number=1000012,createtime=Wed Feb 04 13:22:35 CST 2015,note = null]动态sql通过mybatis提供的各种标签方法实现动态拼接sql。需求：根据性别和名字查询用户查询sql：SELECT id, username, birthday, sex, address FROM user WHERE sex = 1 AND username LIKE ‘%张%’If标签Mapper.xml文件UserMapper.xml配置sql，如下：123456&lt;!-- 根据条件查询用户 --&gt;&lt;select id="queryUserByWhere" parameterType="user" resultType="user"&gt; SELECT id, username, birthday, sex, address FROM `user` WHERE sex = #&#123;sex&#125; AND username LIKE '%$&#123;username&#125;%'&lt;/select&gt;Mapper接口List&lt;User&gt; queryUserByWhere(User user);测试方法在UserMapperTest添加测试方法，如下：123456789101112131415161718192021@Testpublic void testQueryUserByWhere() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行根据条件查询用户 User user = new User(); user.setSex("1"); user.setUsername("张"); List&lt;User&gt; list = userMapper.queryUserByWhere(user); for (User u : list) &#123; System.out.println(u); &#125; // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果123456DEBUG [main] - ==&gt; Preparing: SELECT id, username, birthday, sex, address FROM user WHERE sex = 1 AND username LIKE &apos;张&apos;DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 3User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市]User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州]User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州]如果注释掉user.setSex(“1”)，测试结果如下图：123DEBUG [main] - ==&gt; Preparing: SELECT id, username, birthday, sex, address FROM user WHERE sex = 1 AND username LIKE nullDEBUG [main] - ==&gt; Parameters: nullDEBUG [main] - &lt;== Total: 0测试结果二很显然不合理。按照之前所学的，要解决这个问题，需要编写多个sql，查询条件越多，需要编写的sql就更多了，显然这样是不靠谱的。解决方案，使用动态sql的if标签使用if标签改造UserMapper.xml，如下：123456789101112&lt;!-- 根据条件查询用户 --&gt;&lt;select id="queryUserByWhere" parameterType="user" resultType="user"&gt; SELECT id, username, birthday, sex, address FROM `user` WHERE 1=1 &lt;if test="sex != null and sex != ''"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt;注意字符串类型的数据需要要做不等于空字符串校验。效果123456DEBUG [main] - ==&gt; Preparing: SELECT id, username, birthday, sex, address FROM user WHERE sex = 1 AND username LIKE &apos;张&apos;DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 3User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市]User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州]User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州]如上图所示，测试OKWhere标签上面的sql还有where 1=1 这样的语句，很麻烦可以使用where标签进行改造改造UserMapper.xml，如下1234567891011121314&lt;!-- 根据条件查询用户 --&gt;&lt;select id="queryUserByWhere" parameterType="user" resultType="user"&gt; SELECT id, username, birthday, sex, address FROM `user`&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt; &lt;where&gt; &lt;if test="sex != null"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;效果123456DEBUG [main] - ==&gt; Preparing: SELECT id, username, birthday, sex, address FROM user WHERE sex = 1 AND username LIKE &apos;张&apos;DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 3User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市]User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州]User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州]Sql片段Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的。把上面例子中的id, username, birthday, sex, address提取出来，作为sql片段，如下：123456789101112131415161718192021&lt;!-- 根据条件查询用户 --&gt;&lt;select id="queryUserByWhere" parameterType="user" resultType="user"&gt; &lt;!-- SELECT id, username, birthday, sex, address FROM `user` --&gt; &lt;!-- 使用include标签加载sql片段；refid是sql片段id --&gt; SELECT &lt;include refid="userFields" /&gt; FROM `user` &lt;!-- where标签可以自动添加where关键字，同时处理sql语句中第一个and关键字 --&gt; &lt;where&gt; &lt;if test="sex != null"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 声明sql片段 --&gt;&lt;sql id="userFields"&gt; id, username, birthday, sex, address&lt;/sql&gt;注意：如果要使用别的Mapper.xml配置的sql片段，可以在refid前面加上对应的Mapper.xml的namespaceforeach标签向sql传递数组或List，mybatis使用foreach解析，如下：根据多个id查询用户信息查询sql：SELECT * FROM user WHERE id IN (1,10,24)改造QueryVo在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法Mapper.xml文件UserMapper.xml添加sql，如下：12345678910111213141516&lt;!-- 根据ids查询用户 --&gt;&lt;select id="queryUserByIds" parameterType="queryVo" resultType="user"&gt; SELECT * FROM `user` &lt;where&gt; &lt;!-- foreach标签，进行遍历 --&gt; &lt;!-- collection：遍历的集合，这里是QueryVo的ids属性 --&gt; &lt;!-- item：遍历的项目，可以随便写，，但是和后面的#&#123;&#125;里面要一致 --&gt; &lt;!-- open：在前面添加的sql片段 --&gt; &lt;!-- close：在结尾处添加的sql片段 --&gt; &lt;!-- separator：指定遍历的元素之间使用的分隔符 --&gt; &lt;foreach collection="ids" item="item" open="id IN (" close=")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;测试方法如下图：123456789101112131415161718192021222324@Testpublic void testQueryUserByIds() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行根据条件查询用户 QueryVo queryVo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(10); ids.add(24); queryVo.setIds(ids); List&lt;User&gt; list = userMapper.queryUserByIds(queryVo); for (User u : list) &#123; System.out.println(u); &#125; // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果123456DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id in(?,?,?)DEBUG [main] - ==&gt; Parameters: 1(Integer),10(Integer),22(Integer)DEBUG [main] - &lt;== Total: 3User [id=1, username=李四, sex=2, birthday=null, address=null]User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市]User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州]关联查询商品订单数据模型一对一查询需求：查询所有订单信息，关联查询下单用户信息。注意：因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用户可以下多个订单。sql语句：1234567891011SELECT o.id, o.user_id userId, o.number, o.createtime, o.note, u.username, u.addressFROM `order` oLEFT JOIN `user` u ON o.user_id = u.id方法一：使用resultType使用resultType，改造订单pojo类，此pojo类中包括了订单信息和用户信息这样返回对象的时候，mybatis自动把用户信息也注入进来了改造pojo类OrderUser类继承Order类后OrderUser类包括了Order类的所有字段，只需要定义用户的信息字段即可，如下：1234public class OrderUser extends Order&#123; private String username; private String address;&#125;Mapper.xml在UserMapper.xml添加sql，如下123456789101112131415&lt;!-- 查询订单，同时包含用户数据 --&gt;&lt;select id="queryOrderUser" resultType="orderUser"&gt; SELECT o.id, o.user_id userId, o.number, o.createtime, o.note, u.username, u.address FROM `order` o LEFT JOIN `user` u ON o.user_id = u.id&lt;/select&gt;Mapper接口在UserMapper接口添加方法，如下:1List&lt;OrderUser&gt; queryOrderUser();测试方法：在UserMapperTest添加测试方法，如下：1234567891011121314151617@Testpublic void testQueryOrderUser() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行根据条件查询用户 List&lt;OrderUser&gt; list = userMapper.queryOrderUser(); for (OrderUser ou : list) &#123; System.out.println(ou); &#125; // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果测试结果如下图：小结定义专门的pojo类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。方法二：使用resultMap使用resultMap，定义专门的resultMap用于映射一对一查询结果。改造pojo类在Order类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。改造Order如下:1234567891011121314public class Order&#123; private Integer id; private Integer userId; private String number; private Date createtime; private String note; //附加对象 用户对象 private User user;&#125;Mapper.xml这里resultMap指定orderUserResultMap，如下：123456789101112131415161718192021222324252627282930313233&lt;resultMap type="order" id="orderUserResultMap"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="userId" column="user_id" /&gt; &lt;result property="number" column="number" /&gt; &lt;result property="createtime" column="createtime" /&gt; &lt;result property="note" column="note" /&gt; &lt;!-- association ：配置一对一属性 --&gt; &lt;!-- property:order里面的User属性名 --&gt; &lt;!-- javaType:属性类型 --&gt; &lt;association property="user" javaType="user"&gt; &lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt; &lt;id property="id" column="user_id" /&gt; &lt;result property="username" column="username" /&gt; &lt;result property="address" column="address" /&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 一对一关联，查询订单，订单内部包含用户属性 --&gt;&lt;select id="queryOrderUserResultMap" resultMap="orderUserResultMap"&gt; SELECT o.id, o.user_id, o.number, o.createtime, o.note, u.username, u.address FROM `order` o LEFT JOIN `user` u ON o.user_id = u.id&lt;/select&gt;Mapper接口1List&lt;Order&gt; queryOrderUserResultMap();测试方法在UserMapperTest增加测试方法，如下：1234567891011121314151617@Testpublic void testQueryOrderUserResultMap() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行根据条件查询用户 List&lt;Order&gt; list = userMapper.queryOrderUserResultMap(); for (Order o : list) &#123; System.out.println(o); &#125; // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果测试效果如下图：一对多查询案例：查询所有用户信息及用户关联的订单信息。用户信息和订单信息为一对多关系。sql语句：12345678910111213SELECT u.id, u.username, u.birthday, u.sex, u.address, o.id oid, o.number, o.createtime, o.noteFROM `user` uLEFT JOIN `order` o ON u.id = o.user_id修改pojo类在User类中加入Listorders属性,如下：123456private Integer id;private String username;// 用户姓名private String sex;// 性别private Date birthday;// 生日private String address;// 地址private List&lt;Orders&gt; orders; //附加属性Mapper.xml在UserMapper.xml添加sql，如下：123456789101112131415161718192021222324252627282930313233&lt;resultMap type="user" id="userOrderResultMap"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="username" column="username" /&gt; &lt;result property="birthday" column="birthday" /&gt; &lt;result property="sex" column="sex" /&gt; &lt;result property="address" column="address" /&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;collection property="orders" javaType="list" ofType="order"&gt; &lt;!-- 配置主键，是关联Order的唯一标识 --&gt; &lt;id property="id" column="oid" /&gt; &lt;result property="number" column="number" /&gt; &lt;result property="createtime" column="createtime" /&gt; &lt;result property="note" column="note" /&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 一对多关联，查询订单同时查询该用户下的订单 --&gt;&lt;select id="queryUserOrder" resultMap="userOrderResultMap"&gt; SELECT u.id, u.username, u.birthday, u.sex, u.address, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN `order` o ON u.id = o.user_id&lt;/select&gt;Mapper接口编写UserMapper接口，如下：12//一对多关联查询，用户内部包含该用户的订单 List&lt;User&gt; queryUserOrder();测试方法在UserMapperTest增加测试方法，如下:1234567891011121314151617@Testpublic void testQueryUserOrder() &#123; // mybatis和spring整合，整合之后，交给spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 创建Mapper接口的动态代理对象，整合之后，交给spring管理 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 使用userMapper执行根据条件查询用户 List&lt;User&gt; list = userMapper.queryUserOrder(); for (User u : list) &#123; System.out.println(u); &#125; // mybatis和spring整合，整合之后，交给spring管理 sqlSession.close();&#125;效果123456789101112DEBUG [main] - ==&gt; Preparing: SELECT u.id, u.username, u.birthday, u.sex, u.address, o.id oid, o.user_id, o.number, o.createtime, o.note FROM user u LEFT JOIN orders o ON u.id = o.user_id DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 10User&#123;id=1, username=&apos;王五&apos;, sex=&apos;2&apos;, birthday=null, address=&apos;null&apos;, orders=[Orders&#123;id=3, userId=1, number=&apos;1000010&apos;, createtime=Wed Feb 04 13:22:35 CST 2015, note=&apos;null&apos;, user=null&#125;, Orders&#123;id=4, userId=1, number=&apos;1000011&apos;, createtime=Tue Feb 03 13:22:41 CST 2015, note=&apos;null&apos;, user=null&#125;]&#125;User&#123;id=10, username=&apos;张三&apos;, sex=&apos;1&apos;, birthday=Thu Jul 10 00:00:00 CST 2014, address=&apos;北京市&apos;, orders=[Orders&#123;id=5, userId=10, number=&apos;1000012&apos;, createtime=Thu Feb 12 16:13:23 CST 2015, note=&apos;null&apos;, user=null&#125;]&#125;User&#123;id=16, username=&apos;张小明&apos;, sex=&apos;1&apos;, birthday=null, address=&apos;河南郑州&apos;, orders=[]&#125;User&#123;id=22, username=&apos;陈小明&apos;, sex=&apos;1&apos;, birthday=null, address=&apos;河南郑州&apos;, orders=[]&#125;User&#123;id=24, username=&apos;张三丰&apos;, sex=&apos;1&apos;, birthday=null, address=&apos;河南郑州&apos;, orders=[]&#125;User&#123;id=25, username=&apos;陈小明&apos;, sex=&apos;1&apos;, birthday=null, address=&apos;河南郑州&apos;, orders=[]&#125;User&#123;id=26, username=&apos;王五&apos;, sex=&apos;null&apos;, birthday=null, address=&apos;null&apos;, orders=[]&#125;User&#123;id=27, username=&apos;HuiProgramer&apos;, sex=&apos;男&apos;, birthday=Sun Mar 24 00:00:00 CST 2019, address=&apos;湖南省衡阳市&apos;, orders=[]&#125;User&#123;id=28, username=&apos;彭于晏&apos;, sex=&apos;男&apos;, birthday=Sun Mar 24 00:00:00 CST 2019, address=&apos;湖南&apos;, orders=[]&#125;Mybatis整合spring整合思路SqlSessionFactory对象应该放到spring容器中作为单例存在。传统dao的开发方式中，应该从spring容器中获得sqlsession对象。Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。数据库的连接以及数据库连接池事务管理都交给spring容器来完成。整合需要的jar包spring的jar包Mybatis的jar包Spring+mybatis的整合包。Mysql的数据库驱动jar包。数据库连接池的jar包。整合的步骤创建工程导入jar包加入配置文件mybatisSpring的配置文件的配置文件sqlmapConfig.xmla)数据库连接及连接池b)事务管理（暂时可以不配置）c)sqlsessionFactory对象，配置到spring容器中d)mapeer代理对象或者是dao实现类配置到spring容器中。SqlMapConfig.xml配置文件是SqlMapConfig.xml，如下：123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 2. 指定扫描包，会把包内所有的类都设置别名，别名的名称就是类名，大小写不敏感 --&gt; &lt;package name="cn.itcast.mybatis.pojo" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt;applicationContext.xmlSqlSessionFactoryBean属于mybatis-spring这个jar包对于spring来说，mybatis是另外一个架构，需要整合jar包。applicationContext.xml，配置内容如下:1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置mybatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml" /&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt;&lt;/beans&gt;db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=rootlog4j.properties123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%nDao的开发两种dao的实现方式：原始dao的开发方式使用Mapper代理形式开发方式a)直接配置Mapper代理b)使用扫描包配置Mapper代理需求：实现根据用户id查询实现根据用户名模糊查询添加用户创建pojo123456789public class User &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址get/set。。。&#125;传统dao的开发方式原始的DAO开发接口+实现类来完成。需要dao实现类需要继承SqlsessionDaoSupport类实现Mapper.xml编写User.xml配置文件，如下：1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;!-- 根据用户id查询 --&gt; &lt;select id="queryUserById" parameterType="int" resultType="user"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名模糊查询用户 --&gt; &lt;select id="queryUserByUsername" parameterType="string" resultType="user"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id="saveUser" parameterType="user"&gt; &lt;selectKey keyProperty="id" keyColumn="id" order="AFTER" resultType="int"&gt; select last_insert_id() &lt;/selectKey&gt; insert into user (username,birthday,sex,address) values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt;加载Mapper.xml在SqlMapConfig进行配置:1234&lt;mappers&gt; &lt;!-- 加载User.xml配置文件 --&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;/mappers&gt;实现UserDao接口12345678910111213141516171819202122232425public interface UserDao &#123; /** * 根据id查询用户 * * @param id * @return */ User queryUserById(int id); /** * 根据用户名模糊查询用户列表 * * @param username * @return */ List&lt;User&gt; queryUserByUsername(String username); /** * 保存 * * @param user */ void saveUser(User user);&#125;实现UserDaoImpl实现类编写DAO实现类，实现类必须集成SqlSessionDaoSupportSqlSessionDaoSupport提供getSqlSession()方法来获取SqlSession123456789101112131415161718192021222324252627282930313233343536373839public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Override public User queryUserById(int id) &#123; // 获取SqlSession SqlSession sqlSession = super.getSqlSession(); // 使用SqlSession执行操作 User user = sqlSession.selectOne("queryUserById", id); // 不要关闭sqlSession return user; &#125; @Override public List&lt;User&gt; queryUserByUsername(String username) &#123; // 获取SqlSession SqlSession sqlSession = super.getSqlSession(); // 使用SqlSession执行操作 List&lt;User&gt; list = sqlSession.selectList("queryUserByUsername", username); // 不要关闭sqlSession return list; &#125; @Override public void saveUser(User user) &#123; // 获取SqlSession SqlSession sqlSession = super.getSqlSession(); // 使用SqlSession执行操作 sqlSession.insert("saveUser", user); // 不用提交,事务由spring进行管理 // 不要关闭sqlSession &#125;&#125;配置dao把dao实现类配置到spring容器中，如下:123456789101112&lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置mybatis核心配置文件 --&gt; &lt;property name="configLocation" value="config/sqlMapConfig.xml" /&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Dao --&gt; &lt;bean id="UserDao" class="fun.obey.mybatis.dao.UserDaoImpl"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactoryBean" /&gt; &lt;/bean&gt;测试方法创建测试方法，可以直接创建测试Junit用例。编写测试方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142public class UserDaoTest &#123; private ApplicationContext context; @Before public void setUp() throws Exception &#123; this.context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void testQueryUserById() &#123; // 获取userDao UserDao userDao = this.context.getBean(UserDao.class); User user = userDao.queryUserById(1); System.out.println(user); &#125; @Test public void testQueryUserByUsername() &#123; // 获取userDao UserDao userDao = this.context.getBean(UserDao.class); List&lt;User&gt; list = userDao.queryUserByUsername("张"); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test public void testSaveUser() &#123; // 获取userDao UserDao userDao = this.context.getBean(UserDao.class); User user = new User(); user.setUsername("曹操"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("三国"); userDao.saveUser(user); System.out.println(user); &#125;&#125;Mapper代理形式开发dao实现Mapper.xml编写UserMapper.xml配置文件，如下：123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.UserMapper"&gt; &lt;!-- 根据用户id查询 --&gt; &lt;select id="queryUserById" parameterType="int" resultType="user"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名模糊查询用户 --&gt; &lt;select id="queryUserByUsername" parameterType="string" resultType="user"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id="saveUser" parameterType="user"&gt; &lt;selectKey keyProperty="id" keyColumn="id" order="AFTER" resultType="int"&gt; select last_insert_id() &lt;/selectKey&gt; insert into user (username,birthday,sex,address) values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt;实现UserMapper接口123456789101112131415161718192021222324public interface UserMapper &#123; /** * 根据用户id查询 * * @param id * @return */ User queryUserById(int id); /** * 根据用户名模糊查询用户 * * @param username * @return */ List&lt;User&gt; queryUserByUsername(String username); /** * 添加用户 * * @param user */ void saveUser(User user);&#125;方式一：配置mapper代理在applicationContext.xml添加配置MapperFactoryBean也是属于mybatis-spring整合包1234567&lt;!-- Mapper代理的方式开发方式一，配置Mapper代理对象 --&gt;&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;!-- 配置Mapper接口 --&gt; &lt;property name="mapperInterface" value="cn.itcast.mybatis.mapper.UserMapper" /&gt; &lt;!-- 配置sqlSessionFactory --&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;&lt;/bean&gt;测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243public class UserMapperTest &#123; private ApplicationContext context; @Before public void setUp() throws Exception &#123; this.context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void testQueryUserById() &#123; // 获取Mapper UserMapper userMapper = this.context.getBean(UserMapper.class); User user = userMapper.queryUserById(1); System.out.println(user); &#125; @Test public void testQueryUserByUsername() &#123; // 获取Mapper UserMapper userMapper = this.context.getBean(UserMapper.class); List&lt;User&gt; list = userMapper.queryUserByUsername("张"); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test public void testSaveUser() &#123; // 获取Mapper UserMapper userMapper = this.context.getBean(UserMapper.class); User user = new User(); user.setUsername("曹操"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("三国"); userMapper.saveUser(user); System.out.println(user); &#125;&#125;方式二：扫描包形式配置mapper12345&lt;!-- Mapper代理的方式开发方式二，扫描包方式配置代理 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置Mapper接口 --&gt; &lt;property name="basePackage" value="cn.itcast.mybatis.mapper" /&gt;&lt;/bean&gt;提示：每个mapper代理对象的id就是类名，首字母小写]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP]]></title>
    <url>%2FSpring-AOP.html</url>
    <content type="text"><![CDATA[AOP 前奏WHY AOP?需求1：在程序执行期间追踪正在发生的活动需求2：希望计算器只能处理正数的运算代码实现片段出现的问题代码混乱：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀. 每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点.代码分散：以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 必须修改所有模块.使用动态代理解决上述问题代理设计模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上.ArithmeticCalculator.java12345678package com.spring.aop.impl;public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125;ArithmeticCalculatorimpl.java1234567891011121314151617181920212223package com.spring.aop.helloworld;public class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; return i+j; &#125; @Override public int sub(int i, int j) &#123; return i-j; &#125; @Override public int mul(int i, int j) &#123; return i*j; &#125; @Override public int div(int i, int j) &#123; return i/j; &#125;&#125;ArithmeticCalculatorLoggingProxy.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.spring.aop.helloworld;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class ArithmeticCalculatorLoggingProxy &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingProxy()&#123; ArithmeticCalculator proxy = null; //代理对象由哪一个类加载器负责加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，即其中有哪些方法 Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; //当调用代理对象其中方法时，该执行的方法 InvocationHandler h = new InvocationHandler() &#123; /** * proxy:正在返回的那个代理对象，一般情况下，在invoke方法中都不使用该对象 * method:正在被调用的方法 * args:调用方法时，传入的参数 * */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //日志 System.out.println("The method " + methodName + "begins with " + Arrays.asList(args)); //执行方法 Object result = method.invoke(target,args); //日志 System.out.println("The method " + methodName+ "ends with " + result); return result; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader,interfaces,h); return proxy; &#125;&#125;测试代码1234567891011121314package com.spring.aop.helloworld;public class Main &#123; public static void main(String[] args)&#123; ArithmeticCalculator target = new ArithmeticCalculatorImpl(); ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy(target).getLoggingProxy(); int result = proxy.add(1,2); System.out.println("--&gt;"+result); result = proxy.div(4,3); System.out.println("--&gt;"+result); &#125;&#125;结果：The method addbegins with [1, 2]The method addends with 3--&gt;3The method divbegins with [4, 3]The method divends with 1--&gt;1AOP 简介AOP(Aspect-Oriented Programming, 面向切面编程): 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充.AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点.在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里.AOP 的好处:每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级业务模块更简洁, 只包含核心业务代码.AOP 术语切面(Aspect): 横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象通知(Advice): 切面必须要完成的工作目标(Target): 被通知的对象代理(Proxy): 向目标对象应用通知之后创建的对象连接点（Joinpoint）：程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。例如 ArithmethicCalculator#add() 方法执行前的连接点，执行点为 ArithmethicCalculator#add()； 方位为该方法执行前的位置切点（pointcut）：每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。Spring AOPAspectJ：Java 社区里最完整最流行的 AOP 框架.在 Spring2.0 以上版本中, 可以使用基于 AspectJ 注解或基于 XML 配置的 AOP在Spring中启用AspectJ注解支持要在 Spring 应用中使用 AspectJ 注解, 必须在 classpath 下包含 AspectJ 类库: aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar将 aop Schema 添加到根元素中.要在 Spring IOC 容器中启用 AspectJ 注解支持, 只要在 Bean 配置文件中定义一个空的 XML 元素 aop:aspectj-autoproxy当 Spring IOC 容器侦测到 Bean 配置文件中的 aop:aspectj-autoproxy 元素时, 会自动为与 AspectJ 切面匹配的 Bean 创建代理.用AspectJ注解声明切面要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理.在 AspectJ 注解中, 切面只是一个带有 @Aspect 注解的 Java 类.通知是标注有某种注解的简单的 Java 方法.AspectJ 支持 5 种类型的通知注解:@Before: 前置通知, 在方法执行之前执行@After: 后置通知, 在方法执行之后执行@AfterRunning: 返回通知, 在方法返回结果之后执行@AfterThrowing: 异常通知, 在方法抛出异常之后@Around: 环绕通知, 围绕着方法执行前置通知前置通知:在方法执行之前执行的通知前置通知使用 @Before 注解, 并将切入点表达式的值作为注解值.123456//声明该方法时一个前置通知: 在目标方法开始之前执行 @Before("execution(* com.spring.aop.impl.*.add(..))") public void beforeMethod(JoinPoint joinPoint) &#123; System.out.println("The method begins with "); &#125;标识这个方法是个前置通知, 切点表达式表示执行 ArithmeticCalculator 接口的 add() 方法. * 代表匹配任意修饰符及任意返回值, 参数列表中的 .. 匹配任意数量的参数利用方法签名编写 AspectJ 切入点表达式最典型的切入点表达式时根据方法的签名来匹配各种方法:execution com.atguigu.spring.ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 代表任意修饰符及任意返回值. 第二个 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名.execution public ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 接口的所有公有方法.execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法.合并切入点表达式在 AspectJ 中, 切入点表达式可以通过操作符 &amp;&amp;, ||, ! 结合起来.123456//声明该方法时一个前置通知: 在目标方法开始之前执行 @Before("execution(* com.spring.aop.impl.*.add(int,int))&amp;&amp;execution(* com.spring.aop.impl.*.div(int,int))") public void beforeMethod(JoinPoint joinPoint) &#123; System.out.println("The method begins with "); &#125;让通知访问当前连接点的细节可以在通知方法中声明一个类型为 JoinPoint 的参数. 然后就能访问链接细节. 如方法名称和参数值.12345678//声明该方法时一个前置通知: 在目标方法开始之前执行 @Before("execution(* com.spring.aop.impl.*.*(int,int))") public void beforeMethod(JoinPoint joinPoint) &#123; String MethodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println("The method "+MethodName+" begins with " + args); &#125;标识这个方法是个前置通知, 切点表达式表示执行任意类的任意方法. 第一个 代表匹配任意修饰符及任意返回值, 第二个 代表任意类的对象,第三个 * 代表任意方法, 参数列表中的 .. 匹配任意数量的参数后置通知后置通知是在连接点完成之后执行的, 即连接点返回结果或者抛出异常的时候, 下面的后置通知记录了方法的终止.一个切面可以包括一个或者多个通知.1234567//后置通知：在目标方法执行后（无论是否发生异常），执行的通知 //在后置通知中还不能访问目标方法执行的结果 @After("execution(* com.spring.aop.impl.*.*(..))") public void afterMethod(JoinPoint joinPoint)&#123; String MethodName = joinPoint.getSignature().getName(); System.out.println("The method "+ MethodName+" ends"); &#125;返回通知无论连接点是正常返回还是抛出异常, 后置通知都会执行. 如果只想在连接点返回的时候记录日志, 应使用返回通知代替后置通知.1234567/** * 在方法正常结束受执行的代码 * */ @AfterReturning("execution(* com.spring.aop.impl.*.*(..))") public void afterRunningMethod()&#123; System.out.println("afterRunning... "); &#125;在返回通知中访问连接点的返回值在返回通知中, 只要将 returning 属性添加到 @AfterReturning 注解中, 就可以访问连接点的返回值. 该属性的值即为用来传入返回值的参数名称.必须在通知方法的签名中添加一个同名参数. 在运行时, Spring AOP 会通过这个参数传递返回值.原始的切点表达式需要出现在 pointcut 属性中123456789/** * 在方法正常结束受执行的代码 * 返回通知时可以访问到方法的返回值的！ * */ @AfterReturning(pointcut = "execution(* com.spring.aop.impl.*.*(..))", returning = "result") public void afterRunningMethod(Object result)&#123; System.out.println("afterRunning: " + result); &#125;异常通知只在连接点抛出异常时才执行异常通知将 throwing 属性添加到 @AfterThrowing 注解中, 也可以访问连接点抛出的异常. Throwable 是所有错误和异常类的超类. 所以在异常通知方法可以捕获到任何错误和异常.如果只对某种特殊的异常类型感兴趣, 可以将参数声明为其他异常的参数类型. 然后通知就只在抛出这个类型及其子类的异常时才被执行.123456789/** * 在目标方法出现异常时会执行的代码 * 可以访问到异常对象；且可以指定在出现特定异常时执行通知代码qwx * */ @AfterThrowing(value = "execution(* com.spring.aop.impl.*.*(..))", throwing = "ex") public void AfterThrowingMethod(Exception ex)&#123; System.out.println("AfterThrowing:"+ex); &#125;环绕通知环绕通知是所有通知类型中功能最为强大的, 能够全面地控制连接点. 甚至可以控制是否执行连接点.对于环绕通知来说, 连接点的参数类型必须是 ProceedingJoinPoint . 它是 JoinPoint 的子接口, 允许控制何时执行, 是否执行连接点.在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed() 方法来执行被代理的方法. 如果忘记这样做就会导致通知被执行了, 但目标方法没有被执行.注意: 环绕通知的方法需要返回目标方法执行之后的结果, 即调用 joinPoint.proceed(); 的返回值, 否则会出现空指针异常环绕通知示例代码123456789101112131415161718@Around("execution(* com.spring.aop.impl.*.*(..))") public Object aroundMethod(ProceedingJoinPoint pjd)&#123; Object result = null; String methodName = pjd.getSignature().getName(); try &#123; //执行目标方法 //前置通知 System.out.println("The method " + methodName + " before with " + Arrays.asList(pjd.getArgs())); result = pjd.proceed(); //后置通知 System.out.println("The method " + methodName + " after with"); &#125; catch (Throwable throwable) &#123; //异常通知 System.out.println("The method "+methodName+"occurs exception:"+ throwable); &#125; return result; &#125;指定切面的优先级在同一个连接点上应用不止一个切面时, 除非明确指定, 否则它们的优先级是不确定的.切面的优先级可以通过实现 Ordered 接口或利用 @Order 注解指定.实现 Ordered 接口, getOrder() 方法的返回值越小, 优先级越高.若使用 @Order 注解, 序号出现在注解中12345678910111213/** * 可以使用@Order注解指定切面的优先级，值越小优先级越高 * */@Order(1)@Aspect@Componentpublic class VlidationAspect &#123; @Before("execution(* com.spring.aop.impl.*.*(..))") public void validateArgs(JoinPoint joinPoint)&#123; System.out.println("validate:" + Arrays.asList(joinPoint.getArgs())); &#125;&#125;重用切入点定义在编写 AspectJ 切面时, 可以直接在通知注解中书写切入点表达式. 但同一个切点表达式可能会在多个通知中重复出现.在 AspectJ 切面中, 可以通过 @Pointcut 注解将一个切入点声明成 简单的方法. 切入点的方法体通常是空的, 因为将切入点定义与应用程序逻辑混在一起是不合理的.切入点方法的访问控制符同时也控制着这个切入点的可见性. 如果切入点要在多个切面中共用, 最好将它们集中在一个公共的类中. 在这种情况下, 它们必须被声明为 public. 在引入这个切入点时, 必须将类名也包括在内. 如果类没有与这个切面放在同一个包中, 还必须包含包名.其他通知可以通过方法名称引入该切入点.重用切入点示例代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * 定义一个方法，用于声明切入点表达式，一般地，该方法中再也不需要添入其他的代码 * */ @Pointcut("execution(* com.spring.aop.impl.*.*(..))") public void declareJointPointExpression()&#123;&#125; //声明该方法时一个前置通知: 在目标方法开始之前执行 @Before("declareJointPointExpression()") public void beforeMethod(JoinPoint joinPoint) &#123; String MethodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println("The method "+MethodName+" begins with " + args); &#125; //后置通知：在目标方法执行后（无论是否发生异常），执行的通知 //在后置通知中还不能访问目标方法执行的结果 @After("declareJointPointExpression()") public void afterMethod(JoinPoint joinPoint)&#123; String MethodName = joinPoint.getSignature().getName(); System.out.println("The method "+ MethodName+" ends"); &#125; /** * 在目标方法出现异常时会执行的代码 * 可以访问到异常对象；且可以指定在出现特定异常时执行通知代码qwx * */ @AfterThrowing(value = "declareJointPointExpression()", throwing = "ex") public void AfterThrowingMethod(Exception ex)&#123; System.out.println("AfterThrowing:"+ex); &#125; /** * 在方法正常结束受执行的代码 * 返回通知时可以访问到方法的返回值的！ * */ @AfterReturning(value = "declareJointPointExpression()", returning = "result") public void afterRunningMethod(Object result)&#123; System.out.println("afterRunning: " + result); &#125;用基于XML的配置声明切面除了使用 AspectJ 注解声明切面, Spring 也支持在 Bean 配置文件中声明切面. 这种声明是通过 aop schema 中的 XML 元素完成的.正常情况下, 基于注解的声明要优先于基于 XML 的声明. 通过 AspectJ 注解, 切面可以与 AspectJ 兼容, 而基于 XML 的配置则是 Spring 专有的. 由于 AspectJ 得到越来越多的 AOP 框架支持, 所以以注解风格编写的切面将会有更多重用的机会.基于XML —- 声明切面当使用 XML 声明切面时, 需要在 &lt;beans&gt; 根元素中导入 aop Schema在 Bean 配置文件中, 所有的 Spring AOP 配置都必须定义在 &lt;aop:config&gt; 元素内部. 对于每个切面而言, 都要创建一个 &lt;aop:aspect&gt; 元素来为具体的切面实现引用后端 Bean 实例.切面 Bean 必须有一个标示符, 供 &lt;aop:aspect&gt; 元素引用声明切面的实例代码1234567&lt;!-- 配置切面的bean --&gt; &lt;bean id="calculatorvalidationAspect" class="com.spring.aop.xml.VlidationAspect"&gt;&lt;/bean&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;aop:aspect id = "validationAspect" ref="calculatorvalidationAspect"&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;基于 XML —- 声明切入点切入点使用 &lt;aop:pointcut&gt; 元素声明切入点必须定义在 &lt;aop:aspect&gt; 元素下, 或者直接定义在 &lt;aop:config&gt; 元素下.定义在 &lt;aop:aspect&gt; 元素下: 只对当前切面有效定义在 &lt;aop:config&gt; 元素下: 对所有切面都有效基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他切入点.声明切入点的示例代码12345678910111213141516171819202122&lt;!-- 定义bean --&gt;&lt;bean id="arithmeticCalculator" class="com.spring.aop.xml.ArithmeticCalculatorImpl"&gt;&lt;/bean&gt;&lt;!-- 配置切面的bean --&gt;&lt;bean id="loggingAspect" class="com.spring.aop.xml.LoggingAspect"&gt;&lt;/bean&gt;&lt;bean id="validationAspect" class="com.spring.aop.xml.VlidationAspect"&gt;&lt;/bean&gt;&lt;!-- 配置AOP --&gt;&lt;aop:config&gt;&lt;!-- 配置切点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.spring.aop.xml.*.*(..))" id="pointcut" /&gt; &lt;!-- 配置切面及通知 --&gt; &lt;aop:aspect ref="loggingAspect" order="2"&gt; &lt;aop:before method="beforeMethod" pointcut-ref="pointcut"/&gt; &lt;aop:after method="afterMethod" pointcut-ref="pointcut"/&gt; &lt;aop:after-returning method="afterRunningMethod" pointcut-ref="pointcut" returning="result"/&gt; &lt;aop:after-throwing method="AfterThrowingMethod" pointcut-ref="pointcut" throwing="ex" /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref="validationAspect" order="1"&gt; &lt;aop:before method="validateArgs" pointcut-ref="pointcut" &gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
        <tag>AOP&amp;DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过工厂方法配置Bean]]></title>
    <url>%2F%E9%80%9A%E8%BF%87%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AEBean.html</url>
    <content type="text"><![CDATA[通过调用静态工厂方法创建Bean调用静态工厂方法创建Bean是将对象创建的过程封装到静态方法中。当客户端需要对象时，只需要简单地调用静态方法，而不用关心创建对象的细节。要声明通过静态方法创建的Bean。需要在Bean的class属性里指定拥有该工厂的方法的类，同时在factory-method属性里指定工厂方法的名称，最后，使用&lt;constrctor-arg&gt;元素为该方法传递参数。Car.java1234567891011121314151617181920212223242526272829303132333435363738package com.spring;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public Car(String brand, double price) &#123; this.brand = brand; this.price = price; &#125; public Car() &#123; &#125; @Override public String toString() &#123; return "Car&#123;" + "brand='" + brand + '\'' + ", price=" + price + '&#125;'; &#125;&#125;beans-factory.xml1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 通过静态工厂方法来配置bean，注意不是配置静态工厂方法实例，而是配置bean实例 --&gt; &lt;!-- class 属性： 指向静态工厂方法的全类名 factory-method: 指向静态工厂方法的名字 constructor-arg: 如果工厂方法需要传入参数，则使用constructor-arg 来配置参数 --&gt; &lt;bean id=&quot;car1&quot; class=&quot;com.spring.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt; &lt;constructor-arg value=&quot;audi&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt;MainTest.java12345678910111213package com.test;import com.spring.Car;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainTest &#123; public static void main(String[] args)&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans-factory.xml"); Car car = (Car)applicationContext.getBean("car1"); System.out.println(car); &#125;&#125;运行结果：Car{brand=&#39;audi&#39;, price=300000.0}通过调用实例工厂方法创建Bean实例工厂方法：将对象的创建过程封装到另一个对象实例的方法里。当客户端需要请求对象时，值需要简单的调用该实例方法而不需要关心对象的创建细节。要声明通过实例工厂方法创建的Bean在bean的factory-bean属性里指定拥有该工厂方法的Bean在factory-method属性里指定该工厂方法的名称使用construtor-arg元素为工厂方法传递方法参数Car.java1234567891011121314151617181920212223242526272829303132333435363738package com.spring;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public Car(String brand, double price) &#123; this.brand = brand; this.price = price; &#125; public Car() &#123; &#125; @Override public String toString() &#123; return "Car&#123;" + "brand='" + brand + '\'' + ", price=" + price + '&#125;'; &#125;&#125;InstanceCarFactory.java1234567891011121314151617181920package com.spring;import java.util.HashMap;import java.util.Map;/** * 实例工厂方法：实例工厂的方法，即现需要创建工厂本身，再调用工厂的实例方法来返回bean的实例 * */public class InstanceCarFactory &#123; private Map&lt;String,Car&gt; cars = null; public InstanceCarFactory() &#123; cars = new HashMap&lt;String, Car&gt;(); cars.put("audi",new Car("audi",300000)); cars.put("ford",new Car("ford",400000)); &#125; public Car getCar(String brand)&#123; return cars.get(brand); &#125;&#125;MainTest.java12345678910111213package com.test;import com.spring.Car;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainTest &#123; public static void main(String[] args)&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans-factory.xml"); Car car = (Car)applicationContext.getBean("car2"); System.out.println(car); &#125;&#125;测试结果：Car{brand=&#39;ford&#39;, price=400000.0}]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解开发]]></title>
    <url>%2FSpring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[JavaConfig从Spring 3起，JavaConfig功能已经包含在Spring核心模块，它允许开发者将bean定义和在Spring配置XML文件到Java类中。但是，仍然允许使用经典的XML方式来定义bean和配置，JavaConfig是另一种替代解决方案。所以，在Spring3以后的版本中，支持xml方式和javaConfig两种Spring配置方式。建议：Spring项目用全注解开发，为后期学Spring Boot和Spring Cloud打好基础。通过XML配置Person.java1234567891011121314151617181920212223242526272829303132333435363738package com.spring;public class Person &#123; private String name; private String age; public Person(String name, String age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125;&#125;bean.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean class：bean的全类名，通过反射的方式在IOC容器中创建Bean，所以要求Bean中必须有无参数的构造器 id:标识容器中的bean。id唯一 --&gt; &lt;bean id="person" class="com.Spring.Person"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;Maintest.java123456789101112131415161718package com.Spring;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainTest &#123; public static void main(String[] args)&#123; //1.创建Spring 的IOC容器对象 //ApplicationContext 代表IOC容器 //ClassPathXmlApplicationContext：是ApplicationContext 接口的实现类 ApplicationContext act = new ClassPathXmlApplicationContext("bean.xml"); //2.从IOC容器中获取Bean实例 Person person = (Person)act.getBean("person"); //3.调用toString()方法并打印 System.out.println(person.toString()); &#125;&#125;&#125;结果：Person{name=&#39;HuiProgramer&#39;, age=&#39;21&#39;}以上为Xml配置的方式，Spring3.0后启用注解开发模式。使用注解模式Person.java1234567891011121314151617181920212223242526272829303132333435363738package com.spring;public class Person &#123; private String name; private String age; public Person(String name, String age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125;&#125;AppConfig.java123456789101112131415161718package com.spring;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//相当于beans@Configurationpublic class AppConfig &#123; public AppConfig()&#123; &#125; //相当于bean，默认方法名为Bean的id @Bean public Person person()&#123; return new Person("HuiPerson","21"); &#125;&#125;MainTest.Java123456789101112131415public class Maintest&#123; public static void main(String[] args)&#123; //通过注解获取ApplicationContext ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); //通过类获取Person的bean实例 Person person = context.getBean(Person.class); //打印person System.out.println(person); //通过类型获取所有Bean的person bean实例 String[] names = context.getBeanNamesForType(Person.class); //打印 for(String name:names) System.out.println(name); &#125;&#125;结果：Person{name=&#39;HuiProgramer&#39;, age=&#39;21&#39;}person此为Spring3.0后的注解开发模式！]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
        <tag>Spring注解开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理Bean的生命周期]]></title>
    <url>%2F%E7%AE%A1%E7%90%86Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[IOC容器中Bean的生命周期方法SpringIOC容器可以管理Bean的生命周期，Spring允许在Bean生命周期的特定点执行定制的任务。Spring IOC容器对Bean的生命周期进行管理的过程通过构造器或工厂方法创建Bean为Bean的属性设置值和对其他Bean的引用调用Bean的初始化方法Bean可以使用了当容器关闭时，调用Bean的销毁方法在Bean的声明里设置init-method和destroy-method属性。为Bean指定初始化和销毁方法。Car.java1234567891011121314151617181920public class Car&#123; public Car()&#123; System.out.println("Car's Constructor..."); &#125; private String brand; public void setBrand(String brand)&#123; System.out.println("setBrand..."); this.brand = brand; &#125; public void init()&#123; System.out.println("init..."); &#125; public void destroy()&#123; System.out.println("destroy..."); &#125;&#125;Bean.XML1234&lt;bean id = "car" class = "com.Spring.test.Car" init-method = "init" destroy-method = "destroy"&gt; &lt;property name = "Brand" value = "Audi" /&gt;&lt;/bean&gt;Main.XML1234567891011public class Main&#123; public static void main(String[] args)&#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("Bean.xml"); Car car = (Car)ctx.getBean("car"); System.out.println(car); //关闭IOC容器 ctx.close(); &#125;&#125;输出结果：Car&#39;s Constructor...setBrandinit...com.Spring.test.Car@bb23423destory..创建Bean后置处理器Bean后置处理器允许在调用初始化方法前后对Bean进行额外的处理Bean后置处理器对IOC容器里的所有Bean实例逐一处理，而非单一实例，其典型应用是：检查Bean属性的正确性或根据特定的标准更改Bean的属性对Bean后置处理器而言，需要实现Interface BeanPostProcessor接口，在初始化方法被调用前后。Spring将把每个Bean实例分别传递给上述接口的以下两个方法：添加Bean后置处理器后Bean的生命周期SpringIOC容器对Bean的生命周期进行管理的过程：通过构造器或工厂方法创建Bean实例为Bean的属性设置值和对其他Bean的引用将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization方法调用Bean的初始化方法将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization方法Bean可以使用了当容器关闭时，调用Bean的销毁方法具体操作：MyBeanPostProcessor.java123456789101112public class myBeanPostProcessor implements BeanPostProcessor&#123; @override public Object postProcessBeforeInitialization(Object bean,String beanName) throws BensException&#123; System.out.println("postProcessBeforeInitialization:" + bean + " " + beanName); return bean; &#125; @override public Object postProcessAfterInitialization(Object bean,String beanName) throws BensException&#123; System.out.println("postProcessAfterInitialization:" + bean + " " + beanName); return bean; &#125;&#125;Bean.XML123456789101112131415&lt;bean id = "car" class = "com.Spring.test.Car" init-method = "init" destroy-method = "destroy"&gt; &lt;property name = "Brand" value = "Audi" /&gt;&lt;/bean&gt;&lt;!-- 实现BeanPostProcessor接口，并具体提供Object postProcessBeforeInitialization(Object bean,String beanName)：init-method之前被调用 实现BeanPostProcessor接口，并具体提供Object postProcessAfterInitialization(Object bean,String beanName)：init-method之后被调用 bean: bean实例本身 beanName: IOC容器配置的bean的名字 返回值： 是实际上返回给用户的哪个Bean，注意：可以在以上两个方法中修改返回的bean，甚至返回一个新的bean --&gt;&lt;!-- 配置bean的后置处理器：不需要配置id，IOC容器自动识别是一个BenaPostProcessor --&gt;&lt;bean class = "com.Spring.test.MyBeanPostProcessor"&gt;&lt;/bean&gt;输出结果：Car&#39;s Constructor...setBrandpostProcessBeforeInitialization:com.Spring.test.Car@bb23423 carinit...postProcessBeforeInitialization:com.Spring.test.Car@bb23423 carcom.Spring.test.Car@bb23423destory..添加Bean后置处理器后Bean的生命周期SpringIOC容器对Bean的生命周期进行管理的过程：通过构造器或工厂方法创建Bean实例为Bean的属性设置值和对其他Bean的引用将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization方法调用Bean的初始化方法将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization方法Bean可以使用了当容器关闭时，调用Bean的销毁方法]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring表达式语言(SpEL)]]></title>
    <url>%2FSpring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80-SpEL.html</url>
    <content type="text"><![CDATA[Spring表达式语言：SpELSpring表达式语言（简称SpEL）:是一个支持运行时查询和操作对象图的强大的表达式语言语法类似于EL：SpEL使用#{…}作为定界符，所有在大框号中的字符都被认为是SpELSpEL为bean的属性进行动态赋值提供了便利通过SpEL可以实现：通过bean的id对bean进行引用调用方法以及引用对象中的属性正则表达式的值正则表达式的配置SpEL：字面值整数：&lt;property name = “count” value = “#{5}“/&gt;小数：&lt;property name = “frequency” value = “#{89.7}“/&gt;科学记数法：&lt;property name = “capacity” value = “#{1e4}“/&gt;String可以使用单引号或者双引号作为字符串的定界符号：&lt;property name = “name” value = “#{Chuck}“/&gt;或&lt;property name = ‘name’ value = ‘#{Chuck}‘/&gt;Boolean：&lt;property name = “enabled” value = “#{false}“/&gt;SpEL：引用Bean、属性和方法引用其他对象：12&lt;!-- 通过value属性和 SpEL 配置 Bean 之间的应用关系 --&gt;&lt;property name = "prefix" value = "#&#123;prefixGenerator&#125;"&gt;&lt;/property&gt;引用其他对象的属性12&lt;!-- 通过value属性和 SpEL 配置 suffix 配置值为另一个bean的suffix属性值 --&gt;&lt;property name = "suffix" value = "#&#123;sequenceGenerator2.suffix&#125;"&gt;&lt;/property&gt;调用其他方法，还可以链式操作1234&lt;!-- 过value属性和 SpEL 配置 suffix 配置值为另一个bean的返回值 --&gt;&lt;property name = "suffix" value = "#&#123;sequenceGenerator2.toString()&#125;"&gt;&lt;/property&gt;&lt;!-- 方法的连缀 --&gt;&lt;property name = "suffix" value = "#&#123;sequenceGenerator2.toString().toUpperCase()&#125;"&gt;&lt;/property&gt;SpEL支持的运算符号算数运算符：+,-,*,%,^:12345&lt;property name = "adjustedAmount" value = "#&#123;counter.total + 43&#125;" /&gt;&lt;property name = "adjustedAmount" value = "#&#123;counter.total - 13&#125;" /&gt;&lt;property name = "circumference" value = "#&#123;2* T(java.lang.Math).PI * circle.radius&#125;" /&gt;&lt;property name = "average" value = "#&#123;counter.total / counter.total&#125;" /&gt;&lt;property name = "area" value = "#&#123;T(java.lang.Math).PI * circle.radius * 2&#125;" /&gt;加号还可以用作字符串连接：1&lt;constructor-arg value = "performer.firstName + ' ' + performer.LastName" /&gt;比较运算符：&amp;lt,&amp;gt,==,&lt;=,&gt;=,lt,gt,eq,le,ge12&lt;property name="equal" value = "#&#123;counter.total == 100&#125;" /&gt;&lt;property name="hasCapacity" value = "#&#123;counter.total le 100000&#125;" /&gt;逻辑运算符号：and，or，not，|123&lt;property name="largeCircle" value = "#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;" /&gt;&lt;property name="outOfStock" value = "#&#123;product.available&#125;" /&gt;&lt;property name="outofStock" value = "#&#123;not product.available&#125;" /&gt;if-else运算符：?:(temary),?:(Elvis)1&lt;constructor-arg value = "#&#123;songSelector.seLectSong()=='Jingle BeLLs'?piano:'Jingle Bells'&#125;"/&gt;if-else的字体1&lt;constructor-arg value = "#&#123;kenny.song?:'Greensleeves'&#125;"/&gt;正则表达式:matches1&lt;constructor-arg value = "#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2，4&#125;'&#125;"/&gt;调用静态方法或静态方法:通过T()调用一个类的静态方法，它将返回一个ClassObject，然后再调用相应的方法或者属性：1&lt;property name="initValue" value = "#&#123;T(java.Lang.Math).PI&#125;" /&gt;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean使用外部属性]]></title>
    <url>%2FBean%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[使用外部属性在配置文件里配置Bean时，有时需要在Bean的配置里混入系统部署的细节信息（例如：文件路径，数据源配置信息等）。而这些部署细节实际上需要和Bean部署相分离Spring提供一个PropertyPlaceholderConfigurer的BeanFactory后置处理器，这个处理器允许用户将Bean配置的部分内容外移到属性文件中，可以在Bean配置文件里使用形式为${var}的变量，PropertyPlaceholderConfigurer从属性文件里加载属性，并使用这些属性来替换变量。Spring还允许在属性文件中使用${propName},以实现属性之间的相互引用。注册PropertyPlaceholderConfigurerspring2.0：123&lt;bean class = "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name = "Location" value = "classpath:jdbc.properties"&gt;&lt;/property&gt;&lt;/bean&gt;Spring2.5之后：可通过&lt;context:property-placeholder&gt;元素简化：&lt;beans&gt;中添加context Schema定义在配置文件中加入如下配置：1&lt;context:property-placeholder location= "classpath:db.properties"/&gt;db.properties1234user=rootpassword=1230driverClass=com.mysql.jdbc.DriverjdbcUrl=jdbc:mysql:///testbean.xml12345678910&lt;!-- 导入属性文件 --&gt;&lt;context:property-placeholder location= "classpath:db.properties"/&gt;&lt;!-- 使用外部化属性文件的属性 --&gt;&lt;bean id = "dataSource" class = "com.mchange.v2.c3p0.ComboPoolLedDataSource"&gt; &lt;property name = "user" value = "$&#123;user&#125;"&gt;&lt;/property&gt; &lt;property name = "password" value = "$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name = "driverClass" value = "$&#123;driverClass&#125;"&gt;&lt;/property&gt; &lt;property name = "jdbcUrl" value = "$&#123;jdbcUrl"&gt;&lt;/property&gt;&lt;/bean&gt;输出结果：连接成功]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean的作用域]]></title>
    <url>%2FBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[Bean的作用域：singleton；prototype；WEB环境作用域配置作用域singletonbean.xml1234&lt;!-- 默认作用域是singleton（单例），通过scope配置 。 容器初始化时创建bean实例。在整个容器的生命周期内置创建这一个bean。--&gt;&lt;bean id = "car" class = "com.spring.helloWorld.Car"p:brand = "Audi" p:price = "300000" scope="singleton"&gt;&lt;/bean&gt;Main.java123456public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("bean.xml"); Car car = (Car)ctx.getBean("car"); Car car2 = (Car)ctx.getBean("car"); System.out.println(car == car2);&#125;输出结果：true配置作用域prototypebean.xml1234&lt;!-- 此作用域是prototype（不是单例），通过scope配置。 prototype：原型的，容器初始化时不创建bean的实例，而在每次请求时都创建一个新的Bean实例，并返回。--&gt;&lt;bean id = "car" class = "com.spring.helloWorld.Car"p:brand = "Audi" p:price = "300000" scope="prototype"&gt;&lt;/bean&gt;Main.java123456public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("bean.xml"); Car car = (Car)ctx.getBean("car"); Car car2 = (Car)ctx.getBean("car"); System.out.println(car == car2);&#125;输出结果：false]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean之间的关系]]></title>
    <url>%2FBean%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[Bean之间的关系：继承；依赖Bean配置的继承Spring允许继承bean的配置，被继承的bean成为父bean。继承这个父Bean的Bean称为子Bean子Bean从父Bean中继承配置，包括Bean的属性配置子Bean也可以覆盖从父Bean继承过来的配置父Bean可以作为配置模板，也可以作为Bean的实例。若只想把父Bean作为模板，可以设置&lt;bean&gt;的abstract属性为true，这样Spring将不会实例化这个Bean并不是&lt;bean&gt;元素里的所有属性都会被继承。比如：autowire，abstract等。也可以忽略父Bean的class属性，让子Bean指定自己的类，而共享相同的属性配置，但此时abstract必须设为true继承父Bean实例：123456&lt;bean id = "address" class = "com.spring.helloWorld.Address" p:city = "Beijing" p:street="WuDaoKou"&gt;&lt;/bean&gt;&lt;!-- bean 配置的继承：使用 bean 的 parent 属性指定继承哪个 bean 的配置 --&gt;&lt;bean id = "address2" class = "com.spring.helloWorld.Address" p:street="DaZhongSi" parent = "address"&gt;&lt;/bean&gt;输出结果：Address [city=BeiJing,street=WuDaoKou]Address [city=BeiJing,street=DaZhongSi]抽象Bean实例：12345678&lt;!-- 抽象Bean：bean的abstract属性为true的bean，不能被IOC容器实例化，可以作为模板被继承。若某一个bean的class属性没有指定，则该bean必须是一个抽象bean。 --&gt;&lt;bean id = "address" p:city = "Beijing" p:street="WuDaoKou" abstract = "true"&gt;&lt;/bean&gt;&lt;!-- 继承模板Bean --&gt;&lt;bean id = "address2" class = "com.spring.helloWorld.Address" parent = "address"&gt;&lt;/bean&gt;输出结果：Address [city=BeiJing,street=WuDaoKou]Address [city=BeiJing,street=WuDaoKou]依赖Bean配置Spring允许用户通过depends-on属性设定Bean前置依赖的Bean，前置依赖的Bean会在本Bean实例化之前创建好如果前置依赖于多个Bean，则可以通过逗号，空格的方式配置Bean的名称依赖Bean实例：1234567&lt;!-- 缺少这个bean会报错 --&gt;&lt;bean id = "car" class = "com.spring.helloWorld.Car"p:brand = "Audi" p:price = "300000" &gt;&lt;/bean&gt;&lt;!-- 要求配置Person时，必须有一个关联的car！换句话说person这个bean依赖于Car这个bean，如果缺少就会报错 --&gt;&lt;bean id = "person" class = "com.spring.helloWorld.person"p:name = "Tom" p:address-ref="address2" depends-on="car"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring自动装配]]></title>
    <url>%2FSpring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.html</url>
    <content type="text"><![CDATA[XML配置里的Bean自动装配Spring IOC容器可以自动装配Bean。需要做的仅仅是在&lt;bean&gt;的autowire属性里指定自动装配的模式byType(根据类型自动装配)：若IOC容器中有多个与目标Bean类型一致的Bean。在这种情况下，Spring将无法判定哪个Bean最适合属性，所以不能执行自动装配。byName(根据名称自动装配)：必须将目标Bean的名称和属性名设置完全相同。constructor（通过构造器自动装配）：当Bean中存在多个构造器时，此种自动装配方式将会很复杂。不推荐使用自动装配byName实例：123456789&lt;!-- 通过p命名空间为bean的属性赋值，需要先导入 p 命名空间,相对于传统的配置更加的简洁 --&gt;&lt;bean id = "address" calss = "com.spring.hellowrld.address" p:city = "Beijing" p:street = "HuiLongGuan"&gt;&lt;/bean&gt;&lt;!-- 通过p命名空间为bean的属性赋值，需要先导入 p 命名空间,相对于传统的配置更加的简洁 --&gt;&lt;bean id = "car" calss = "com.spring.hellowrld.Car" p:brand = "Audi" p:price = "30000"&gt;&lt;/bean&gt;&lt;!-- 可以使用 autowire 属性指定自动装配的方式 byName 根据 bean 的名字和当前bean的 setter 风格的属性名进行自动装配，若有匹配的，则进行自动装配，若没有匹配的，则不装配 --&gt;&lt;bean id = "Person" calss = "com.spring.hellowrld.person" p:name = "Tom" autowire = "byName"&gt;&lt;/bean&gt;自动装配byType实例：12345678&lt;!-- 通过p命名空间为bean的属性赋值，需要先导入 p 命名空间,相对于传统的配置更加的简洁 --&gt;&lt;bean id = "address2" calss = "com.spring.hellowrld.address" p:city = "Beijing" p:street = "HuiLongGuan"&gt;&lt;/bean&gt;&lt;!-- 通过p命名空间为bean的属性赋值，需要先导入 p 命名空间,相对于传统的配置更加的简洁 --&gt;&lt;bean id = "car2" calss = "com.spring.hellowrld.Car" p:brand = "Audi" p:price = "30000"&gt;&lt;/bean&gt;&lt;!-- byType 根据 bean 的类型和当前 bean 的属性的类型进行自动装配，若IOC容器中有一个以上的类型匹配的bean，则抛异常。 --&gt;&lt;bean id = "Person2" calss = "com.spring.hellowrld.person" p:name = "Rose" autowire = "byType"&gt;&lt;/bean&gt;XML配置里的Bean自动装配的缺点在 Bean 配置文建立设置 autowire 属性进行自动装配将会装配 Bean 的所有属性。然而，若值希望装配个别属性时， autowire属性就不够灵活了。autowire 属性要么根据类型自动装配，要么根据名称自动装配，不能两者兼而有之。一般情况下，在实际项目中很少使用自动装配功能，因为和自动装配功能所带来的好处比起来，明确清晰的配置文档更有说服力一些。]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常见错误]]></title>
    <url>%2FHexo%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[启用腾讯云图床错误为了加快网站访问，本站启用了腾讯云图床，但就在生成文章时，出现了一系列问题。最终将问题定在md文件里。解决办法将平常用的md语法改写为&lt;img&gt;标签，并将在主题目录下的images文件夹里新产生的文件夹删除。1234&lt;!-- 出现错误的方式 --&gt;![Error](https://blog-1258364678.cos.ap-guangzhou.myqcloud.com/Hexo_error1.png "Error")&lt;!-- 正确的方式 --&gt;&lt;img src = "https://blog-1258364678.cos.ap-guangzhou.myqcloud.com/Hexo_error1.pn" title = "Error" alt ="Error"&gt;总结出现问题时，要多多分析可能存在的原因；只有找到源头时，才能解决问题。]]></content>
      <categories>
        <category>前端</category>
        <category>Node.js</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>常见错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的配置]]></title>
    <url>%2FSpring%E4%B8%ADBean%E7%9A%84%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[IOC&amp;DI概述配置Bean配置形式：基于XML文件的方式；基于注解的方式Bean的配置方式：通过全类名（反射）、通过工厂方法（静态工厂方法&amp;实例工厂方法）、FactoryBeanIOC容器BeanFactory&amp;ApplicationContext概述依赖注入的方式：属性注入；构造器注入注入属性值的细节自动装配bean之间的关系：继承；依赖bean的作用域：singleton；prototype；WEB环境作用域使用外部属性文件spELIOC容器中的Bean的生命周期Spring4.x新特性：泛型依赖注入IOC和DIIOC(Inversion of Control)：其思想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC之后，则是容器主动地将资源送给它所管理的组件，组件要做的仅仅是选择一种合适的方式来介绍资源。这种行为也被称为查找的被动形式DI(Dependency Injection)–IOC的另一种表述方式：即组件以一些预先定义好的方式（例如：setter方法）接受来自如容器的资源注入。相对于IOC而言，这种表述更直接IOC&amp;DI原理IOC前生 — 分离接口与实现需求：生成HTML或PDF格式的不同类型的报表IOC前生 — 采用工厂设计模式IOC — 采用反转控制Bean的配置方式在Spring的IOC容器里配置Bean在XML文件中通过bean节点来配置bean1234&lt;!-- 通过全类名的方式来配置bean --&gt;&lt;bean id = "helloWorld" class = "com.spring.helloworld.HelloWorld"&gt;&lt;/bean&gt;id:Bean的名称在IOC容器中必须是唯一若id没有指定，Spring自动将权限定性类名作为Bean的名字id可以指定多个名字，名字之间可用逗号、分号、或者空格分隔Spring容器在SpringIOC容器容器读取Bean配置创建Bean实例之前，必须对它进行实例化。只有在容器实例化后，才可以从IOC容器里获取Bean实例并使用。Spring提供了两种类型的IOC容器实现。BeanFactory:IOC容器的基本实现。ApplicationContext：提供了更多的高级特性。是BeanFactory的子接口。BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都直接使用ApplicationContext而非底层的BeanFactory无论使用何种方式，配置文件时相同的。ApplicationContextApplicationContext的主要实现类：ClassPathXmlApplicationContext:从类路径下加载配置文件FileSystemXmlApplicationContext：从文件系统中加载配置文件ConfigurableApplicationContext扩展与ApplicationContext，新增两个主要方法：refresh()和close(),让ApplicationContext具有启动、刷新和关闭上下文的能力ApplicationContext在初始化上下文时就实例化所有单例的Bean。WebApplicationContext是专门为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作从IOC容器中获取BeanBeanFactoryFACTORY_BEAN_PREFIX:StringgetBean(String):ObjectgetBean(String,Class&lt;T&gt;)&lt;T&gt;:TgetBean(Class&lt;T&gt;)&lt;T&gt;:TgetBean(String,Object…):ObjectcontainsBean(String):booleanisSingleton(String):booleanisPrototype(String):booleanisTypeMatch(String,Class&lt;?&gt;):booleangetType(String):Class&lt;?&gt;getAliases(String):String[]具体实例12345678//1.创建Spring 的IOC容器对象 //ApplicationContext 代表IOC容器 //ClassPathXmlApplicationContext：是ApplicationContext 接口的实现类 ApplicationContext act = new ClassPathXmlApplicationContext("spring-config.xml"); //2.从IOC容器中获取Bean实例 HelloWorld helloWorld = (HelloWorld)act.getBean("helloWorld"); //3.调用hello方法 helloWorld.hello();属性注入属性注入即通过setter方法注入Bean的属性值或依赖的对象属性注入使用&lt;property&gt;元素，使用name属性指定Bean的属性名称，value属性或&lt;value&gt;子节点指定属性值属性注入是实际应用中最常见的注入方式123456&lt;!-- 通过全类名的方式来配置bean --&gt;&lt;bean id = "helloWorld" class = "com.spring.helloworld.HelloWorld"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="age" value="22"&gt;&lt;/property&gt;&lt;/bean&gt;构造方法注入通过构造方法注入Bean的属性值或者依赖的对象，它保证了Bean实例在实例化后就可以使用构造器注入在&lt;constructor-arg&gt;元素里声明属性，&lt;constructor-arg&gt;中没有name属性按顺序配置123456&lt;!-- 通过构造方法来配置bean属性 --&gt;&lt;bean id = "car" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "ShangHai"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "30000"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;按index配置123456&lt;!-- 通过构造器注入属性值可以指定参数的位置 --&gt;&lt;bean id = "car" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi" index = "0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "30000" index = "2"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "ShangHai" index = "1"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;按type配置123456&lt;!-- 通过构造器注入属性值可以指定参数的类型 --&gt;&lt;bean id = "car" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi" type = "java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "30000" type = "long"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "ShangHai" type = "java.lang.String"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;提示: 通过构造器注入参数的类型和位置可以混合使用字面值字面值：可用字符串表示的值，可以通过&lt;value&gt;元素标签或value属性进行注入基本数据类型及其封装类，String等类型都可以采用字面值注入的方式若字面值中包含特殊字符，可用使用&lt;![CDATA[]]&gt;把字面值包裹起来实例：123456789&lt;!-- 通过构造器注入属性值可以指定参数的位置和类型 --&gt;&lt;bean id = "car2" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi" index = "0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "30000" index = "2"&gt;&lt;/constructor-arg&gt; &lt;!-- 如果字面值包含特殊字符可以用&lt;![CDATA[ ]]&gt;包裹起来 --&gt; &lt;constructor-arg type = "java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;输出结果：&lt;ShangHai&gt;引用其它Bean组成应用程序的Bean经常需要相互协作以完成应用程序的功能，要使Bean能够相互访问，就必须在Bean配置文件中指定对Bean的引用在Bean的配置文件中，可用通过&lt;ref&gt;元素或ref属性为Bean的属性或构造器参数指定对Bean的引用也可以在属性或构造器里包含Bean的声明,这样的Bean称为内部Bean外部Bean实例：12345&lt;!-- 通过方法注入属性值 --&gt;&lt;bean id = "person" calss = "com.spring.hellowrld.person"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="Car" ref = "car"&gt;&lt;/property&gt;&lt;/bean&gt;内部Bean实例：123456789101112&lt;!-- 通过方法注入属性值 --&gt;&lt;bean id = "person" calss = "com.spring.hellowrld.person"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="Car"&gt; &lt;!-- 通过构造器注入属性值可以指定参数的类型 --&gt; &lt;bean id = "car" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi" type = "java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "30000" type = "long"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "ShangHai" type = "java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;null值和级联属性可以使用专用的&lt;null/&gt;元素标签为Bean的字符串或其它对象类型的属性注入null值和Struts、Hiberante等框架一样，Spring支持级联属性的配置。null值注入实例:1234567&lt;!-- 通过构造方法来配置bean属性 --&gt;&lt;bean id = "car3" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi"&gt;&lt;/constructor-arg&gt; &lt;!-- 注入null值 --&gt; &lt;constructor-arg &gt;&lt;value&gt;&lt;null/&gt;&lt;/value&gt;&lt;/constructor-arg&gt; &lt;constructor-arg &gt;&lt;value&gt;&lt;null/&gt;&lt;/value&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;级联属性的配置:1234567&lt;!-- 通过方法注入属性值 --&gt;&lt;bean id = "person" calss = "com.spring.hellowrld.person"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="Car" ref = "car"&gt;&lt;/property&gt; &lt;!-- 给级联属性赋值,注意：属性需要先初始化后才可以给级联属性赋值，否则会发生异常，和Struts2不同 --&gt; &lt;property name="Car.corp" value = "50000"&gt;&lt;/property&gt;&lt;/bean&gt;集合属性在Spring中可以通过一组内置的XML标签（例如：&lt;list&gt;,&lt;set&gt;或&lt;map&gt;）来配置集合属性配置java.util.List类型的属性，需要指定&lt;list&gt;标签，在标签里包含一些元素，这些标签可以通过&lt;value&gt;指定简单的常量值，通过&lt;ref&gt;指定对其他Bean的引用，通过&lt;bean&gt;指定内置Bean定义。通过&lt;null/&gt;指定空元素，设置可以内嵌其他集合数组的定义和List一样，都使用&lt;list&gt;配置java.util.Set需要使用&lt;set&gt;标签，定义元素的方法与List一样。Java.util.Map通过&lt;map&gt;标签定义，&lt;map&gt;标签里可以使用多个&lt;entry&gt;作为子标签，每个条目包含一个键和一个值。必须在&lt;key&gt;标签里定义键因为键和值的类型没有限制，所以可以自由地为他们指定&lt;value&gt;,&lt;ref&gt;,&lt;bean&gt;或&lt;null&gt;元素。可以将Map的键和值作为&lt;entry&gt;的属性定义：简单常量使用key和value来定义；Bean引用通过key-ref和value-ref属性定义使用&lt;props&gt;定义java.util.Properties,该标签使用多个&lt;prop&gt;作为子标签，每个&lt;prop&gt;标签必须定义key属性.List实例：123456789101112131415161718&lt;!-- 通过方法注入属性值 --&gt;&lt;bean id = "person" calss = "com.spring.hellowrld.person"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="Cars" &gt; &lt;!-- 使用list节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean = "car2" /&gt; &lt;ref bean = "car3" /&gt; &lt;!-- 通过Bean直接指定 --&gt; &lt;bean id = "car" class = "com.spring.helloworld.Car"&gt; &lt;constructor-arg value = "Audi" type = "java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "30000" type = "long"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value = "ShangHai" type = "java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;Map实例：123456789101112&lt;!-- 配置Map属性值 --&gt;&lt;bean id = "Person" calss = "com.spring.hellowrld.person"&gt; &lt;property name = "name" value = "Rose"&gt;&lt;/property&gt; &lt;property name = "age" value = "28"&gt;&lt;/property&gt; &lt;property name = "Cars"&gt; &lt;!-- 使用 map 节点及map的entry子节点配置 Map --&gt; &lt;map&gt; &lt;entry key = "AA" value-ref = "car3"&gt;&lt;/entry&gt; &lt;entry key = "BB" value-ref = "car2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;Properties实例：123456789101112&lt;!-- 配置Properties 属性值 --&gt;&lt;bean id = "dataSource" calss = "com.spring.hellowrld.dataSource"&gt; &lt;property name = "properties"&gt; &lt;!-- 使用 props 和 prop 子节点来为 Properties 属性赋值 --&gt; &lt;props&gt; &lt;prop key = "user"&gt;root&lt;/prop&gt; &lt;prop key = "password"&gt;1234&lt;/prop&gt; &lt;prop key = "jdbcUrl"&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key = "driverClass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;使用utility scheme定义集合使用基本的集合标签定义集合时，不能将集合作为独立的Bean定义，导致其他Bean无法引用该集合，所以无法在不同Bean之间共享集合。可以使用util schema里的集合标签定义独立的集合Bean，需要注意的事，必须在&lt;beans&gt;根元素里添加退了 schema 定义。配置单例集合Bean:12345678910111213&lt;!-- 配置单例的集合Bean，以供多个bean进行引用，需要导入util命名空间 --&gt;&lt;util:list id = "cars"&gt; &lt;ref bean = "car3" /&gt; &lt;ref bean = "car2"&gt;&lt;/util:list&gt;&lt;bean id = "Person2" calss = "com.spring.hellowrld.person"&gt; &lt;property name = "name" value = "Tom"&gt;&lt;/property&gt; &lt;property name = "age" value = "22"&gt;&lt;/property&gt; &lt;!-- 被引用 --&gt; &lt;property name = "Cars" ref = "cars"&gt; &lt;/property&gt;&lt;/bean&gt;使用P命名空间为了简化XML文件的配置，越来越多的XML的XML文件采用属性而飞子元素配置信息。Spring从2.5版本开始引入了一个新的p命名空间，可以通过&lt;bean&gt;元素属性的方式配置Bean的属性。使用p命名空间后，基于XML的配置方式将进一步简化。123&lt;!-- 通过p命名空间为bean的属性赋值，需要先导入 p 命名空间,相对于传统的配置更加的简洁 --&gt;&lt;bean id = "person3" class = "com.spring.hellowrld.person" p:age = "30" p:name = "Queen" p:car-ref="cars"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的HelloWorld(使用Idea)]]></title>
    <url>%2FSpring%E7%9A%84HelloWorld%EF%BC%88%E4%BD%BF%E7%94%A8Idea%EF%BC%89.html</url>
    <content type="text"><![CDATA[创建Spring项目我们在idea中创建一个Spring项目，具体如下：勾选Spring选择好后点击Next选择项目路径以及项目名（自动下载所需jar包）简单的IOC（反转控制）我们在src目录下新建com.Test包，并创建一个HelloWorld类，实现一个简单的自我介绍功能，代码如下：12345678910111213141516171819202122232425package com.Test;public class HelloWorld &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void hello()&#123; System.out.println("我是"+name+",今年"+age+"岁啦"); &#125;&#125;Bean的配置接下来我们配置Spring-config.xml文件1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean class：bean的全类名，通过反射的方式在IOC容器中创建Bean，所以要求Bean中必须有无参数的构造器 id:标识容器中的bean。id唯一 --&gt; &lt;bean id="hello" class="com.Test.HelloWorld"&gt; &lt;property name="name" value="HuiProgramer"&gt;&lt;/property&gt; &lt;property name="age" value="22"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;注意：这里使用的是属性注入，通过getxx(),setxx()方法。解析：name为setxx()方法的xx，value为setxx()方法里面的行参。运行效果这里我们再新建一个类Main来运行看效果：123456789101112131415161718package com.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args)&#123; //1.创建Spring 的IOC容器对象 //ApplicationContext 代表IOC容器 //ClassPathXmlApplicationContext：是ApplicationContext 接口的实现类 ApplicationContext act = new ClassPathXmlApplicationContext("spring-config.xml"); //2.从IOC容器中获取Bean实例 HelloWorld helloWorld = (HelloWorld)act.getBean("hello"); //3.调用hello方法 helloWorld.hello(); &#125;&#125;&#125;运行后的结果：]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习路线图]]></title>
    <url>%2FJava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE.html</url>
    <content type="text"><![CDATA[JavaJava是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 。Java学习路线图如何学习JavaJava基础Java 是一门纯粹的面向对象的编程语言，所以除了基础语法之外，必须得弄懂它的 oop 特性：封装、继承、多态。此外还有泛型、反射的特性，很多框架的技术都依赖它，比如 Spring 核心的 Ioc 和 AOP，都用到了反射，而且 Java 自身的动态代理也是利用反射实现的。此外还有 Java 一些标准库也是非常常见，比如集合、I/O、并发，几乎在 Web 开发中无处不在，也是面试经常会被问到的，所以在自学 Java 后端之前，不妨先打好这些基础，另外还有 Java8 的一些新特性，也要重点关注，比如 Lambda 表达式、集合的 Stream 流操作、全新的 Date API 等等数据库SQL建议学习MySQL在你了解了一些基础语法之后，就可以开始实战演练了，多练习熟练了就可以了。JDBC你需要弄懂 JDBC API 的用法，其实它只是一组规范接口，所有数据库驱动只要实现了 JDBC，那么我们就可以通过标准的 API 调用相应的驱动，完全不用知道驱动是怎么实现的，这就是面向接口编程的好处。Web基础Http 协议可以参考：Http协议JSP你只要了解它其实就是一个 Servlet 就行了，关于它的一些标签用法，我认为可以直接忽略，因为现在互联网几乎没哪间公司还用 JSP，除了一些老旧的项目。现在都是流行前后端分离，单页应用，后端只做 API 接口的时代了，所以时间宝贵，把这些时间重点放在 Servlet 规范上面吧。Tomcat它是一个 Web 容器，我们写的后端项目都要部署到Web容器才能运行，它其实是一个遵循 Http，通过 Socket 通信与客户端进行交互的服务端程序.可以参考：Tomcat结构及处理请求过程Web 主流框架Java Web 框架多如牛毛，等你有一定经验了，你也可以写一个 Web 框架，网上很多说 Spring、Struts2、Hibernate 是 Java 三架马车，我只想说，那是很久远的事情了，我严重不推荐 Struts2、Hibernate，相信我，一开始只需要上手 Spring、SpringMVC、Mybatis 就可以了，特别是 Spring 框架，其实 Spring 家族的框架都是很不错的。但是提醒一点就是，千万不要沉迷于各种框架不能自拔，以会多种用法而沾沾自喜，导致知其然而不知其所以然。Spring核心思想就是 IOC 和 AOP：谈谈对 Spring IOC 的理解Spring 面向切面编程SpringMVC它的思想是全部请求统一用一个 Servlet 去做请求转发与控制，这个 Servlet 叫 DispatcherServlet：SpringMVC 初始化过程SpringMVC 处理请求过程Mybatis它可实现动态拼装 sql，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集：mybatis 入门教程Mybatis 深入浅出系列Web 框架进阶使用了 SSM 框架后，你会觉得框架也不过这么回事，如果你对 Spring 有过大概了解，你也会产生想写一个「山寨版」Spring 的心思了，一个轻量级 Web 框架主要具备以下功能：可读取用户自定义配置文件，并以此来初始化框架；具备 Bean 容器，管理项目的类的对象生命周期；具备依赖注入，降低类之间的耦合性；具备 AOP 功能，使项目可进行横向编程，可不改变原有代码的情况增加业务逻辑；具备 MVC 框架模式。其实除了 SSM 之外，Web 框架可谓是百家齐放，其中以 Spring 全家桶最为耀眼，在这里我极力推荐两个 Spring 家族框架：SpringBoot 和 SpringCloud。SpringBoot弥补了 Spring 配置上的缺点，再也不用为繁杂的 xml 费劲精力了，堪称是 Java 后端开发的颠覆者，推荐书籍「Java EE 开发的颠覆者：SpringBoot实战」SpringBoot 构建 web 项目SpringBoot 自动化配置源码分析自定义 SpringBoot Starterspring-boot-starter-tutorialSpringCloud一个微服务架构，能够将项目按照业务分成一个个微服务，每个微服务都可独立部署，服务之间互相协调。当一个项目越来越大时，随之而来的是越来越难以维护，此时将项目拆分成若干个微服务、单独维护、单独部署，也可以降低项目不同业务间的耦合度。推荐书籍「Spring Cloud 与 Docker 微服务架构实战」，这本书将 Docker 与微服务完美地结合在一起，堪称完美！Spring Cloud 中文官网史上最简单的 Spring Cloud 教程关于 Spring Cloud 的博客有：SpringCloud微服务架构之服务注册与发现SpringCloud微服务架构之服务消费者SpringCloud微服务架构之断路器SpringCloud微服务架构之服务网关其它技术Redis一个高性能的 key-value 数据库，当有并发量很高的请求时，将数据缓存在 Redis 中，将提高服务器的响应性能，大大减轻数据库的压力。redis 中文官网redis 教程Git世界上最先进的分布式版本控制系统，建议所有初学者从命令行开始使用 Git！Git 官网Git 教程Maven一个用于构建项目的工具，将项目间的依赖通过 xml 完美地组织到一起，可通过编译插件将项目编译成字节码文件。还有类似的 Gradle 也是不错的选择。maven 的 pom.xml 文件详解Linux：至少要求常用的命令会用，能够在 linux 环境下部署项目。Linux 命令大全最全的 SSH 连接远程终端教程Docker简直是项目部署神器啊，来不及解释了，看下面一些 Docker 系列博客，开启 Docker 之旅吧！推荐书籍「Docker 技术入门与实战」，中国首部 Docker 著作！Docker 实战（一）Docker 实战（二）Docker 实战（三）docker-deploy-tutorial原文地址Java学习路线图]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程（持续更新）]]></title>
    <url>%2FGit%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[GIT （分布式版本控制系统）简介Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。什么是Git，Git可以用来干嘛？GIt是什么？Git是目前世界上最先进的分布式版本控制系统Git可以用来干嘛？如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档就“魂飞魄散”了！过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这个软件用起来就应该像这个样子，能记录每次文件的改动：版本用户说明日期1张三删除了软件服务条款57/12 10:382张三增加了License人数限制7/12 18:093李四财务部门调整了合同金额7/13 9:514张三延长了免费升级周期7/14 15:17Git与SVN的区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。Git 与 SVN 区别点：GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。Git 各平台安装包下载地址为：http://git-scm.com/downloads在Linux平台安装GitGit 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：Debian/UbuntuDebian/Ubuntu Git 安装命令为：1234567$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \ libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2Centos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：1234567$ yum install curl-devel expat-devel gettext-devel \ openssl-devel zlib-devel$ yum -y install git-core$ git --versiongit version 1.7.1在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/ 。第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！Git配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。用户信息配置个人的用户名称和电子邮件地址：12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。注意: 用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。查看配置信息要检查已有的配置信息，可以使用 git config –list 命令：1234$ git config --listcredential.helper=manageruser.name=ProgramerHuiuser.email=1712817197@qq.comGit工作流程一般工作流程如下：克隆 Git 资源作为工作目录。在克隆的资源上添加或修改文件。如果其他人修改了，你可以更新资源。在提交前查看修改。提交修改。在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。Git工作区、暂存区和版本库基本概念工作区：就是你在电脑里能看到的目录。暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。当执行 “git rm –cached“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 “git checkout .” 或者 “git checkout –“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 “git checkout HEAD .” 或者 “git checkout HEAD“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。Git创建版本库(仓库)什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：12345$ pwd/c/Users/Administrator$ cd E:$ mkdir Git$ cd Gitpwd命令用于显示当前目录，cd命令用于切换目录，mkdir用于创建文件夹，在我的Windows上，这个仓库位于E:/Git.注意：文件夹应避免使用中文，防止乱码。让文件夹成为真正的仓库上面步骤只是创建了一个文件夹，严格意义上并不算是一个Git版本库，so，现在，我们让这个文件夹变成一个真正的仓库。输入git init命令把这个目录变成Git可管理的仓库12$ git initInitialized empty Git repository in E:/Git/.git/瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。建议：编辑文本最好使用Notepad++代替记事本，因为微软自带记事本会在每个文件开头添加0xefbbbf（十六进制）的字符。现在，我们编写一个readme.txt文件，内容如下:1Hello,Git!注意:文件应该放在Git文件夹里，因为这是一个Git仓库，放到其他地方Git会找不到这个文件。Git add通过git add告诉Git，把文件添加到仓库（暂存区）：1$ git add readme.txt执行上面的命令，没有任何显示,代表执行成功。Git commit通过git commit告诉Git，把文件提交到仓库（版本库）：1234$ git commit -m "wrote a readme file"[master (root-commit) eacdf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt其中：git commit -m &quot;wrote a readme file&quot;中的-m &quot;xxx&quot;代表本次提交的说明。例如：$ git commit -m &quot;本次提交解决了若干个BUG&quot;当然,提交说明也可以带表情，具体表情参考Github表情提交指南。Git 基本操作获取和创建项目命令git init此命令在创建版本库的时候就讲过，git init命令就是将一个文件夹初始化为一个Git仓库，创建成功后在该文件夹下会生成一个.git的文件夹.例如：12$ git initInitialized empty Git repository in E:/Git/.git/现在你能看见该仓库中的.git文件了。12$ ls -a. .. .git注意：这里的ls -a中的ls就是列表，清单的意思，在终端就是显示当前目录的所有文件，而-a的意思是显示隐藏文件。git clone使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。1$ git clone [url]url是你想克隆（复制）的网上仓库。例如：我们克隆Github上的项目1234567$ git clone git@github.com:HuiProgramer/HTML5_Learning.gitCloning into 'HTML5_Learning'...remote: Counting objects: 26, done.remote: Total 26 (delta 0), reused 0 (delta 0), pack-reused 26Receiving objects: 100% (26/26), done.Resolving deltas: 100% (5/5), done.Checking connectivity... done.克隆完成后，在当前目录下会生成一个 HTML5_Learning 目录：1234$ cd HTML5_Learning&amp; lsCSS/ index.html logo.png Screen1.pngimg/ JavaScript/ README.MD Screen2.png至此，一个Github上的项目就克隆完成了，你可以尝试修改或者查看。常用命令git add此命令前面就讲过了，这里再举一个例子，这次我们往暂存区添加多个文件：123456789101112131415161718$ touch hello.py hello.c hello.java hello.html$ lshello.py hello.c hello.java hello.html$ git add hello.c hello.java hello.html hello.py$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: hello.c new file: hello.html new file: hello.java new file: hello.py我们分别向暂存区提交了多个语言hello world程序源文件，touch代表我们新建这几个文件，git status的意思是查看当前暂存区的状态。扩展： 通过git add .可以将该文件夹的东西都添加到暂存区。git statusgit status用于查看在你上次提交之后是否有修改，便于查看当前暂存区的状态，通过增加-s参数可以获得简短的输出结果，如果没有加该参数将会得到详细的输出。例如：123456789101112131415161718$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: hello.c new file: hello.html new file: hello.java new file: hello.py$ git status -sA hello.cA hello.htmlA hello.javaA hello.py补充说明：A的意思是文件添加到了暂存区，而AM的意思是文件添加到暂存区后在工作区又有所改动。git diff执行 git diff 来查看执行 git status 的结果的详细信息。git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有如下几个主要的应用场景。尚未缓存的改动（工作区）：git diff查看已缓存的改动（暂存区）： git diff –cached查看已缓存的与未缓存的所有改动（工作区与暂存区）：git diff HEAD显示摘要而非整个 diff：git diff –stat例如我们利用notepad++编辑器修改hello.c文件内容如下：12345#include&lt;stdio.h&gt;int main(void)&#123; printf("hello,world"); return 0;&#125;现在我们使用git diff file命令来看看结果：123456789101112$ git diff hello.cdiff --git a/hello.c b/hello.cindex e69de29..fb0c3bd 100644--- a/hello.c+++ b/hello.c@@ -0,0 +1,5 @@+#include&lt;stdio.h&gt;+int main(void)&#123;+ printf("hello,world");+ return 0;+&#125;\ No newline at end of file果然，git将整个文件的变化都列了出来。扩展：diff就是单词different的缩写，其原意是“区别，不同”。git commit此命令在讲述创建版本库的时候就介绍过，主要用于将暂存区的东西提交到版本库中。例如：12345678910111213$ git status -sAM hello.cA hello.htmlA hello.javaA hello.py$ git commit -m"第一次提交"[master (root-commit) ac81931] 第一次提交 4 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 hello.c create mode 100644 hello.html create mode 100644 hello.java create mode 100644 hello.py我们将暂存区的内容提交到版本库后再次执行git status命令123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.cno changes added to commit (use "git add" and/or "git commit -a")此时，我们发现，暂存区的内容已经全部提交到版本库中，只有一条工作区内容被修改的记录。git reset HEADgit reset HEAD file 命令用于取消已缓存(暂存区)的内容。可以理解为：撤销暂存区的修改。可单个撤销，也可以全部撤销。这里，我们先提交hello.c源文件123456789101112131415161718$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.cno changes added to commit (use "git add" and/or "git commit -a")$ git add hello.c$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.c好的，现在hello.c源文件已经进入了暂存区了，那么，如果我不想提交该内容，该怎么解决呢？其实，通过git reset HEAD命令是可以丢弃掉暂存区里的内容的。现在，我们来试试吧！12345678910111213$ git reset HEADUnstaged changes after reset:M hello.c$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.cno changes added to commit (use "git add" and/or "git commit -a")果然，暂存区的内容被撤销掉了。要点：git reset HEAD filename实现单个或多个文件在暂存区中撤销，git reset HEAD实现整个暂存区的撤销。注意：如果你提交暂存区后，在工作区又进行了修改，git reset HEAD命令并不会让你在工作区的内容回退到上一次提交的数据，该只是单纯的丢弃掉暂存区里的内容。git checkout – filegit checkout --file命令用于取消未缓存的内容（工作区）。可以理解为：丢弃工作区的修改，回到上次修改的样子。那么，我们现在来试试1234567891011121314151617181920$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.cno changes added to commit (use "git add" and/or "git commit -a")$ cat hello.c#include&lt;stdio.h&gt;int main(void)&#123; printf("hello,world"); return 0;&#125;$ git checkout -- hello.c$ cat hello.c在这里，我们使用git status命令可以看到该文件只是在工作区进行了修改，接着我们使用了cat命令查看了文件内容，发现里面是C语言源代码，然后我们使用了git checkout -- hello.c命令丢弃了本次修改。等我们再次使用cat命令查看hello.c内容时发现里面已经没有内容了，这是为什么呢？原来这里的git checkout -- &lt;file&gt;命令的结果分为了两种情况:当文件在工作区修改后还没有被添加到暂存区，此时使用该命令，会使工作区回到和版本库一模一样的状态。当文件在工作区修改后被添加到了暂存区，此时使用该命令，会使工作区回到把文件添加到暂存区后的状态那么，这里就是第一种状态了，因为我们并没有提交到暂存区，而版本库的hello.c里面恰恰是没有内容的。（因为当时并没有写内容）git rm如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作1$ rm &lt;file&gt;如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f1$ rm -f &lt;file&gt;如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可1$ git rm --cached &lt;file&gt;我们先在hello.py增加如下代码1print("hello")然后，我们将文件添加到暂存区后，在暂存区中删除hello.py文件12345678910111213141516171819202122$ git add hello.py$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.py$ git rm --cached hello.pyrm 'hello.py'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: hello.pyUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) hello.py可以看到，我们在暂存区移除了该文件，现在，我们将工作区的文件也移除掉。1234$ rm hello.pyrm 'hello.py'$ lshello.c hello.html hello.java至此，基本命令到此结束。Git查看提交历史git log在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。123456$ git logcommit ac81931794f4e232398796f5d4e09be155fc5bc2 (master)Author: ProgramerHui &lt;1712817197@qq.com&gt;Date: Fri Dec 28 19:17:51 2018 +0800 第一次提交git log –onelinegit log --oneline 命令用来查看历史记录的简洁的版本。12$ git log --onelineac81931 (master) 第一次提交git log –graphgit log --graph 命令，用于查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：123456$ git log --graph* commit ac81931794f4e232398796f5d4e09be155fc5bc2 (master) Author: ProgramerHui &lt;1712817197@qq.com&gt; Date: Fri Dec 28 19:17:51 2018 +0800 第一次提交git log –authorgit log --author命令用于查看指定用户的提交日志。示例如下：123456$ git log --author=ProgramerHuicommit ac81931794f4e232398796f5d4e09be155fc5bc2 (master)Author: ProgramerHui &lt;1712817197@qq.com&gt;Date: Fri Dec 28 19:17:51 2018 +0800 第一次提交Git版本回退早在前面就说过Git能干什么的特性.你可以理解为Git就是一个时空穿梭机，能够回退版本和前进版本。现在，我们来修改一下readme.txt的内容。1234567$ cat readme.txthello,Git$ echo "HuiProgramer is handsome!" &gt;&gt; readme.txt$ cat readme.txtHuiProgramer is handsome!扩展：echo &quot; &quot; &gt;&gt; file是一个批处理命令，用于清空文件内容后，将” “里的内容写入到文件中。我们尝试提交一下123456$ git add readme.txt$ git commit -m"handsome"[master dd18d87] handsome 1 file changed, 1 insertion(+) create mode 100644 readme.txt我们现在来回忆一下我们一共提交了哪几个版本的readme.txt文件。版本一：hello,Git版本二：HuiProgramer is handsome记不住也没事，我们可以通过git log命令来查看：123456789101112$ git logcommit dd18d87073e5d9a593dbfe3a89072e9f785431ad (HEAD -&gt; master)Author: ProgramerHui &lt;1712817197@qq.com&gt;Date: Sun Jan 6 12:07:01 2019 +0800 handsomecommit ac81931794f4e232398796f5d4e09be155fc5bc2Author: ProgramerHui &lt;1712817197@qq.com&gt;Date: Fri Dec 28 19:17:51 2018 +0800 wrote a readme file可以看到第一次提交就是开始介绍GIt仓库时写的readme.txt,里面的内容是hello,Git.而最近一次提交就是我们重新修改了readme.txt后提交的，里面的内容是HuiProgramer is handsome(表脸).那么，如果我想要回到上一个版本该怎么办呢？其实很简单只需要执行git reset --hard HEAD^就行了，其中^代表上一个版本，^^代表上上个版本，以此类推。12$ git reset --hard HEAD^HEAD is now at ac81931 wrote a readme fileLook，我们已经回到了上一个版本了，现在我们打开readme.txt文件看看。hello,Git哇，果然是这样，但我又如何回去呢？就像我们现在坐着时空穿梭机回到了过去，应该怎么回到现在呢？其实很简单，我们可以通过上次执行git log命令拿到的commit后面的版本号再次穿梭就可以回来了。12$ git reset --hard dd18HEAD is now at dd18d87 handsome注意：版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。再次查看readme.txt的内容HuiProgramer is handsome嗯，不错，内容全回来了，还是一如既往的表脸。扩展：假如我关闭了git bash这个终端，然后又回退了版本，输入git log又不显示，该怎么办呢？其实很简单，你只要输入git reflog命令就能再次看到你的提交记录了。1234567891011121314151617181920$ git reflogdd18d87 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to dd18ac81931 HEAD@&#123;1&#125;: reset: moving to HEAD^dd18d87 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: handsomeac81931 HEAD@&#123;3&#125;: checkout: moving from Python to masteraf26cd8 (Python) HEAD@&#123;4&#125;: checkout: moving from master to Pythonac81931 HEAD@&#123;5&#125;: checkout: moving from Python to masteraf26cd8 (Python) HEAD@&#123;6&#125;: commit: test branchac81931 HEAD@&#123;7&#125;: checkout: moving from master to Pythonac81931 HEAD@&#123;8&#125;: checkout: moving from Python to masterac81931 HEAD@&#123;9&#125;: checkout: moving from master to Pythonac81931 HEAD@&#123;10&#125;: checkout: moving from Python to masterac81931 HEAD@&#123;11&#125;: checkout: moving from master to Pythonac81931 HEAD@&#123;12&#125;: checkout: moving from Python to masterac81931 HEAD@&#123;13&#125;: checkout: moving from master to Pythonac81931 HEAD@&#123;14&#125;: reset: moving to HEADac81931 HEAD@&#123;15&#125;: reset: moving to HEADac81931 HEAD@&#123;16&#125;: reset: moving to HEAD^5a56f73 HEAD@&#123;17&#125;: commit: hello worldac81931 HEAD@&#123;18&#125;: commit (initial): wrote a readme fileGit与Github什么是GithubGitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。简单来说就是一个网上的仓库，而Git就是本地的仓库。拥有自己的Github注册Github账号点击这里进行注册。注册完成后，登录…创建自己的项目（仓库/版本库）点击+号进行创建填写项目名字，点击完成即可。完成后，会得到项目的提交地址。创建SSH Key打开Git Bash终端，输入：1$ ssh-keygen -t rsa -C "youremail@example.com"你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。绑定SSH Key进入Github,点击头像，点击Settings。点击SSH and GPG Keys点击New SSH key可以看到此页面Title可以随便取一个，Key可以去C:\Users\Administrator\.ssh下找到一个id_rsa.pub的文件，双击打开后复制里面的全部内容粘贴到Key下的框框里，然后点击Add SSH Key.创建完成后就能看到这样的页面…提交项目到Githubgit remote通过git remote add origin git@github.com:YourName/RepositoryName.git即可建立一个与当前分支关联的提交名字。1$ git remote add Golang git@github.com:HuiProgramer/Golang_Learning.git解析：YourName为你的Github账户名,RepositoryName为你创建的项目名。注意：这里的origin可以任你更改，前提你得记住，后面提交要用到。git push通过git push -u origin master命令可将本地项目推送到Github的仓库中。12345678910$ git push -u Golang masterCounting objects: 9, done.Delta compression using up to 2 threads.Compressing objects: 100% (6/6), done.Writing objects: 100% (9/9), 916 bytes | 152.00 KiB/s, done.Total 9 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To github.com:HuiProgramer/Golang_Learning.git * [new branch] master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;Golang&apos;.Look,我们已经成功提交本地版本库到网上仓库了。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。现在，我们打开我们的远程仓库看看，是否提交成功。嗯，不错，成功了，以后就这样提交。git pull通过git pull origin master可将网上仓库拉取到本地来完成同步。1234$ git pull Golang masterFrom github.com:HuiProgramer/Golang_Learning * branch master -&gt; FETCH_HEADAlready up to date.现在就会看到，本地项目和网上仓库一模一样了。Git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。分支的创建和切换创建分支命令：1$ git branch (branchname)切换分支命令：1git checkout (branchname)例如：12345$ git branch Python$ git checkout PythonSwitched to branch 'Python'D hello.py扩展：git checkout -b (branchname)命令可以创建并切换新分支，从而实现在该分支中的操作。]]></content>
      <categories>
        <category>前端</category>
        <category>版本控制系统</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[MarkdownMarkdown介绍Markdown是一种轻量级的标记语言，使用普通的文本编辑器，通过简单的标记语法，就可以实现漂亮的排版，被越来越多的写作爱好者、程序员所使用。Markdown自成格式，不依赖任何编辑器，且易于传播，其语法十分简单，通过几分钟的简单学习，就可以实现基本的排版，然后专注于码字。用途Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。常用语法常用语法表格输出后的效果Markdown快捷键加粗**text**Ctrl+B斜体*text*Ctrl+I链接[title](http://)Ctrl+L代码块`code`Ctrl+k图片![alt](http://)Ctrl+G有序列表1. itemCtrl+Shift+O无序列表* itemCtrl+U块级引用> quoteCtrl+Q一级标题# HeadingCtrl+1二级标题## HeadingCtrl+2标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注意：每个#后面必须跟一个空格示例：123#### 这是四级标题##### 这是五级标题###### 这是六级标题效果如下：这是四级标题这是五级标题这是六级标题字体加粗要加粗的字体左右分别用两个*号包起来斜体要倾斜的文字左右分别用一个*号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来代码示例:1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~有序无序列表有序列表通过数字1234567…后面加一个.和空格实现。无序列表通过*,-,+其中之一加一个空格来实现无序列表。代码示例：1234567891011121. 我是有序列表* 我是由*号生成无序列表* 我是由*号生成无序列表* 我是由*号生成无序列表2. 我是有序列表- 我是由-号生成无序列表- 我是由-号生成无序列表- 我是由-号生成无序列表3. 我是有序列表+ 我是由+号生成无序列表+ 我是由+号生成无序列表+ 我是由+号生成无序列表效果如下：我是有序列表我是由*号生成无序列表我是由*号生成无序列表我是由*号生成无序列表我是有序列表我是由-号生成无序列表我是由-号生成无序列表我是由-号生成无序列表我是有序列表我是由+号生成无序列表我是由+号生成无序列表我是由+号生成无序列表块级引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容效果如下：这是引用的内容这是引用的内容这是引用的内容代码块单行代码块通过`code`来展示单行代码块内容示例：`I’m single code.`效果如下：I&#39;m single code.多行代码块通过```code```来展示多行代码块内容示例：```Python(指定语言)def example():&emsp;&emsp;for i in range(10):&emsp;&emsp;&emsp;&emsp;print(“hello”)```效果如下：123def example(): for i in range(10): print("hello")图片语法：![图片alt](图片地址 ‘’图片title’’)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加示例：1![头像](https://ws3.sinaimg.cn/large/006MOU0zgy1g19n0u9anzj30jg0kbabt.jpg "头像icon")效果如下：链接语法：[超链接名](超链接地址 “超链接title”)title可加可不加示例：12[baidu](http://baidu.com)[博客](https://www.52share.online)效果如下：baidu博客表格语法：123456:---:|:---:|文字居中显示:---|:---文字靠左显示---:|---:文字靠右显示示例：123456789101112131415161718示例1：表格文字居中|表格文字居中|表格文字居中:---:|:---:|:---:文字居中|文字居中|文字居中文字居中|文字居中|文字居中示例2：表格文字靠左|表格文字靠左|表格文字靠左:---|:---|:---文字靠左|文字靠左|文字靠左文字靠左|文字靠左|文字靠左示例3：表格文字靠右|表格文字靠右|表格文字靠右---:|---:|---:文字靠右|文字靠右|文字靠右文字靠右|文字靠右|文字靠右示例1：表格文字居中表格文字居中表格文字居中文字居中文字居中文字居中文字居中文字居中文字居中示例2：表格文字靠左表格文字靠左表格文字靠左文字靠左文字靠左文字靠左文字靠左文字靠左文字靠左示例3：表格文字靠右表格文字靠右表格文字靠右文字靠右文字靠右文字靠右文字靠右文字靠右文字靠右]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长难句分析（特殊结构的长难句）]]></title>
    <url>%2F%E9%95%BF%E9%9A%BE%E5%8F%A5%E5%88%86%E6%9E%90%EF%BC%88%E7%89%B9%E6%AE%8A%E7%BB%93%E6%9E%84%E7%9A%84%E9%95%BF%E9%9A%BE%E5%8F%A5%EF%BC%89.html</url>
    <content type="text"><![CDATA[二、特殊结构的长难句分裂结构嵌套结构平行结构特殊结构的长难句：分裂结构There is growing fear among vice-chancellors that this revenue——as well as the cultural, academic and economic benefit international students bring——is being put at risk.(CET-4, 201312 仔细阅读2)There is growing fear among vice-chancellors that this revenue is being put at risk.(CET-4, 201312 仔细阅读2)特殊结构的长难句：嵌套结构Among the government’s most interesting reports is one that estimates what parents spend on their children.(CET-6, 201312 仔细阅读 1)A survey of 439 medical technicians found that 55 percent of technicians who monitor bypass machines acknowledged that they had talked on cellphones during heart surgery.(CET-4,201406 仔细阅读 1)A sunrvey … found &emsp;&emsp;&emsp;&emsp;宾语从句 &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;定语从句&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;定语从句that 55 percent of technicianswho monitor bypass machinesacknowledgedthat they had..特殊结构的长难句：平行结构The English, the Germans, the Dutch and the French were investing in Britain’s former colony.The English,the Germans,the Dutchand the Frenchwere investing in Britain’s former colony.Both areas are critical to producing citizens who can participate effectively in our democratic society, become innovative leaders, and benefit from the spiritual enrichment that teh reflection on the great ideas of mankind over time provides.(CET-4, 201406 仔细阅读 1)Several hours after a meal, people’s hunger levels were predicted not by how much they’d eaten but rather by how much food they’d seen in front of them…(CET-4, 201312 仔细阅读 1)But brains are the superior choice when you want information to change, in interesting and useful ways: to connect up with other facts and ideas, to acquire successive layers of meaning, to steep for a while in your accumulated knowledge and experience…(CET-6, 201406 仔细阅读 1)长难句综合运用indeed, according to surveys, employers have expressed a preference for students who have received a broadly-based education that has taught them to write well, think critically, research creatively and communicate easily.(CET-4, 201406 仔细阅读 1)Cole and Fredrickson found that people who are happy but have little to no sense of meaning in their lives have the same gene expression patterns as people who are responding to and enduring chronic adversity.(CET-6, 201412 长篇阅读)]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长难句分析（基本结构的长难句）]]></title>
    <url>%2F%E9%95%BF%E9%9A%BE%E5%8F%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E7%9A%84%E9%95%BF%E9%9A%BE%E5%8F%A5%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、基本结构的长难句断开简化基本结构的长难句&emsp;长难句&emsp;多个句子/多件事&emsp;简单句&emsp;一个句子/一件&emsp;简单句的核心&nbsp;一件事的核心内容断开1 标点&emsp;2 连接词&emsp;&emsp;3 分析主谓简化1 定位谓语动词2 去修饰找核心基本结构的长难句：1. 断开（1）标点（2）连接词：从句开始于连接词，结束于？（3）分析主谓&emsp;1) 标点&emsp;2) 下一个连接词前&emsp;3) 第二个谓语动词前连接词断开，结束于标点But this is a real-life argument before a Superme Court that has a well-earned reputation for looking out for the interests of large corporations.(CET-6,201312 仔细阅读 2)If it has to hire a caregiver for every two children,it can’t really achieve any economics of scale on labor to save money when other expenses go up.(CET-4,201412 仔细阅读 1)More than half of all recent graduates are unemployed or in jobs that do not require a degree, and the amount of student-loan debt carried by households has increased more than five times since 1999.(CET-4,201312 长篇阅读)Imagine the number of teaching jobs that might be eliminated if this could be done for math,economics,chemistry,and so on.(CET-6,201406 长篇阅读)Although it has been nearly 30 years since the first commercial mobile-phone network was launched, advertisers have yet to figure out how to get their messages out to mobile-phone users in a big way.(CET-4,201312 选词填空)连接词断开，结束于第二个谓语动词前Those who stay on for an additional two years can earn a master’s degree that qualifies them as nurse practitioners or clinical nurse spercialists.(CET-4,201312 选词填空)People who score on personality tests as more sympathetic cry more than those who are more rigid or have more self-control.(CET-4,201406 长篇阅读)Though the United States has fewer women in the workforce, American women who choose to be employed are far more likely to work full-time and to hold high-level jobs as managers or professionals.(CET-6,201406 长篇阅读)断开：分析主谓This is the best movie I have seen.The present he gave me was very amazing.Some scientists maintain that the changes we are seeing fall within the range of random variation…(CET-4,201406 选词填空)Some scientists maintain thatthe changes we are seeing fall within the range of random variation…(CET-4,201406 选词填空)When these students encounter a new problem of the same type on a test, they’re able to transfer the knowledge they’ve gathered more effectively than those who were the passive recipients of someone else’s expertise.(CET-6,201312 仔细阅读 1)二、简化：去修饰，留核心修饰成分有：形容词、副词介词短语非谓语动词(doing/done/to do)冠词、数词非限定性定语从句Over the past few months it has been working hard, with the help of media consultants, to play down its cosy reputation in favour of something more academic and serious(CET-6,201412 仔细阅读 2)Printing with moveable type on paper dramatically reduced the cost of producing a book compared with the old-fashioned ones handwritten on vellum, which comes from sheepskin.(CET-4,201406 长篇阅读)A generation ago, female faces were rare and, even today, visitors walking through the first floor of LeConte Hall will see a full corridor of exhibits honoring the many distinguished physicists who made history here,virtually all of them white males.(CET-4,201312 选词填空)基本结构的长难句：断开 + 简化The same dramatic technological changes that have provided marketers with more communications choices have also increased the risk that passionate consumers will voice their opinions in quicker, more visible, and much more damaging ways.The same dramatic technological changes 1 have also increased the risk 2.that have provided marketers with more communications choices.that passionate consumers will voice their opinions in quicker, more visible, and much more damaging ways.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊用途的句子(虚拟句)]]></title>
    <url>%2F%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E7%9A%84%E5%8F%A5%E5%AD%90-%E8%99%9A%E6%8B%9F%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第三章 虚拟1. 什么是虚拟？2. 怎么表示虚拟？3. 虚拟常用于？1. If 虚拟条件句（虚拟语气）&emsp;（1）虚拟条件句（假设现在）&emsp;If 从句主句假设过去&emsp;would假设现在did(were)could/should&emsp;&emsp; + do假设将来&emsp;mightIf I were you, I would do it now.练习：I am not you, so I can’t make the decision.I don’t know his phone number, so I won’t ring him up.He isn’t free at the moment, so he won’t go to the cinema.补充：If I could rearrange the alphabet, I would put U and I together.&emsp;（2）虚拟条件句（假设过去）&emsp;If 从句主句假设过去had donewould + have done假设现在&emsp;could/should假设将来&emsp;mightIf they had won the match, they would have held a party to celebrate.练习：He was not a student, so he couldn’t attend the lecture.He didn’t tell her the answer. She didn’t understand it.You were late, so you didn’t hear what he told us.&emsp; （3）虚拟语气（假设将来）&emsp;If 从句主句假设过去&emsp;would假设现在&emsp;could/should假设将来did(were)were to doshould domight + doIf I were to live my life over again, I would have you as my life.练习：如果我明天有时间，我就会帮他。（明天不太可能有时间）If I had time tomorrow（were to have/should have）,I would help him.总结：&emsp;If 从句主句假设过去had donewould + have done假设现在did(were)could/should + do假设将来did(were)were to doshould domight + doIf 非真实条件句（混合时态的虚拟）&emsp;If 从句主句假设过去&emsp;&emsp;假设现在&emsp;&emsp;假设将来&emsp;&emsp;如果你（过去）嫁给他，你（现在）就会是一个加油站服务员的妻子。If you had married him, you would be the wife of a gas station attendant.省略 If 的虚拟条件句If you had joined us, we would have had more fun.If I were you, I would think it twice.2. 名词性从句的虚拟语气：表示“建议，要求，命令”动词后的宾语从句虚拟从句中用（should）+ doHe suggested that the system should be changed.suggest, advise, propose, recommend, order, ask, demand, insist, require, request……练习：宾语从句的虚拟语气The engineers proposed they (look) at the design again.He insisted that she (send) her sister to a dancing school.The workers demanded they (give) the wages they should get.He ordered they (start) the attack before dawn.The teacher always suggests the students (go) over the text before the best.the professor recommended we (look) for the information in the library.总结：表示 “建议，要求，命令” 的名词性从句He suggested that the system should be changed.His suggestion was that the system should be changed.He gave the suggestion that the system should be changed.This year,it was suggested that the system should be changed.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊用途的句子(倒装句)]]></title>
    <url>%2F%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E7%9A%84%E5%8F%A5%E5%AD%90-%E5%80%92%E8%A3%85%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第二章 倒装全部倒装/部分倒装1. 全部倒装：In the mountain lies a castle.Here comes the bus.全部倒装：There be 句型1. There be + n. “有”（客观存在）There is a girl.2. There be + n + 介词短语 “有…在哪里”（客观存在）There is a book on the table.There is no gap between mind and matter.注意：1）be 动词的变化&emsp;&emsp;&emsp;&emsp;&nbsp; There will now be a seven-day wait for jobseeker’s allowance.&emsp;&emsp;&emsp;2）主语的单复数&emsp;&emsp;&emsp;3）There 还可以与情态动词搭配&emsp;&emsp;&emsp;&emsp;&nbsp; There may be more matches in the database.2. 部分倒装：相当于把陈述句变成疑问句三种情况需要倒装（1）否定词位于句首&emsp;not, no, never, hardly, little, scarcely, seldom, not until, not only……（2）only 位于句首（3）虚拟if条件句举例：The poor man had not only been arrested but he had been sent to prison as well.Not only had the poor man been arrested, but he had been sent to prison as well.We can learn English well only in this way.Only in this way can we learn English well.练习：1. You will never know the truth.Never .2. He cares little for my words.Little .3. I had no sooner got the invitation than I refused.No sooner .4. He had hardly had time to settle down when he left the country.Hardly .5. He achieved his goal only by working hard.Only by working hard .6. Natural disasters will reduce, only when we solve the problems of environmental pollution.Only when .]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊用途的句子(强调句)]]></title>
    <url>%2F%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E7%9A%84%E5%8F%A5%E5%AD%90-%E5%BC%BA%E8%B0%83%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第一章 强调强调句It is ….. that …..I want to go to America this summer.It is America that I want to go to this summer.补充：强调过去时态：It was …. that …强调人时：It is …. that/who …练习：It is they. not American, who have become anti-intellectual.It is they who have become anti-intellectual.It is … that …写作：Lisa likes cooking at home.We used to have meetings in the cafe.They celebrated the holiday on Nov.11th.Students don’t like too much homework.Men can solve the problems of natural disaster only by controlling the environmental pollution.注意：一个句子的动词和形容词不能强调。]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的补充(复合句/状语从句)]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85-%E5%A4%8D%E5%90%88%E5%8F%A5-%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第三章 状语从句1.状语从句的含义：一个句子作状语，表达描述性的信息。2.状语从句的写法：从属连词 + 完整的陈述句&emsp;从属连词时间状语从句when, while, as, before, after, since, until&emsp;as soon as, no sooner…than地点状语从句where原因状语从句because, since, as结果状语从句so/such…that, so that…目的状语从句so that…,in order that条件状语从句if, unless, as long as让步状语从句although, though, even though, as比较状语从句than, as方式状语从句as地点状语从句Stay where you are.Where there is a will, there is a way.结果状语从句The problem is so complicated that we cannot solve it.It is such a complicated problem that we cannot solve it.让步状语从句Although it is summer, it is very cold.It is summer, but it is very cold.比较状语从句I am as tall as you.I am as tall as you(are).方式状语从句Do it as I told you yesterday.When in Rome, do as Romans do.3.状语从句的时态：时间/条件状语从句中表示将来，要换成一般现在时。如果明天下雨，我们就不去公园。If it rains tomorrow, we will not go for a picnic.I will let him know, when he comes home later.改错练习：The boss will review your work after she will return from vacation next week.(returns)I’ll give you a call on my cell phone as soon as my plane will land .(lands)I don’t like my current job, but I’m going to stay with this company until I will find something better.(find)If it won’t be cold tomorrow. we’ll go to the beach.(isn’t)If it will be cold tomorrow, we will go to a movie.(is)4.状语从句的位置：If it rains tomorrow, we will not go to the park.We will not go to the park, If it rains tomorrow.We, If it rains tomorrow, will not go to the park.练习：He speaks English well indeed, but of course not _ a native speaker.A. as fluent as &emsp;&emsp;&emsp;&emsp;B. more fluent thanC. as fluently as &nbsp;&emsp;&emsp;&emsp;D. much fluently thanThe couple had no sooner got to the station _ the coach left.A. when &emsp;&emsp;B. as &emsp;&emsp;C. until &emsp;&emsp;D. thanMy parents don’t mind what job I do _ I am happy.A. even though &emsp;B. as soon as &emsp;C. as long as &emsp;D. as thoughThe medicine works more effectively _ you drink some hot water after taking it.A. as &emsp;&amp;emspB. until &emsp;&emsp;C. although &emsp;&emsp;D. if__ the police thought he was the most likely one, since they had no exact proof about it,they could not arrest him.A. Although &emsp;B. As long as &emsp;C. If only &emsp;D. As soon asIt just isn’t fair. __ I was working as a waiter last month, my friends were lying on the beach.A. whenever &emsp;B. though &emsp;C. for &emsp;D. whileShall we have our picnic tomorrow?_ it doesn’t rain.A.Until &emsp;&emsp;B. While &emsp;&emsp;C. Once &emsp;&emsp;D. IfThe Great Wall is _ tourist attraction that millions of people pour in every year.A. so a well-known &emsp;&emsp;&emsp;B. a so well-knownC. such well-known a &emsp;&emsp;D. such a well-knownOwen wouldn’t eat anything _ he cooked it himself.A. until &emsp;&emsp;B. since &emsp;&emsp;C. unless &emsp;&emsp;D. while答案1.C 2.D 3.C 4.D 5.A 6.D 7.D 8.D 9.C]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的补充(复合句/定语从句)]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85-%E5%A4%8D%E5%90%88%E5%8F%A5-%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第二章 定语从句1. 定语从句的含义：一个句子作定语，去修饰限定名词。2. 定语从句的写法：先把主句和从句写出两个句子，再把从句合并进去修饰限定名词。This is the 我梦想很多年的 job.This is the job. I have dream of the job for years.This is the job Which I have dreamed of for years.&emsp;&emsp;&emsp;&emsp;&emsp;↓&emsp;&emsp;&emsp;↓&emsp;&emsp;先行词 关系词&emsp;&emsp;关系词如何选择？&emsp;&emsp;&emsp;&emsp;看先行词！&emsp;先行词 = ？物人人的/物的时间地点原因&emsp;关系词 = ？which/thatwho/whom/thatwhosewhenwherewhy练习关系词的选择：1. I have a class begins at 8:00 am.2. The lawyer my brother called didn’t answer the phone.3. My daughter asked me a question I couldn’t answer.4. The people sat in the stadium cheered for the home team.5. Leo is the student bike was stolen.6. Australia is one of the few countries people drive on the left.7. Sunday is the day people usually don’t go to work.8. Is there any particular reason you can’t come?答案1. which/that 2. 不填/whom/that 3. 不填/that/which 4. who5. whose 6. where 7. when 8. why练习写定语从句1. I lost the book .&emsp;我弄丢了上周从图书馆借的书。2. The woman was feeding pigeons.&emsp;我在公园看见的那位女士正在喂鸽子。3. The bus is usually very crowed.&emsp;我每天上学坐的那辆公交车总是很拥挤。答案1. which/that/不填 I borrowed from the library 2. who/that/whom/不填 I saw in the park 3. which/that/不填 I take every day to school3. 定语从句的分类：I met your friend who is staying in Paris.&emsp;&emsp;&emsp;&emsp;限定性定语从句I met your mother,who is staying in Paris.&emsp;&emsp;&emsp;&nbsp;非限定性定语从句This is the wall which they built last week.This is the Great Wall, which is world-famous.练习（填入逗号和关系词）:1. He came from Beijing is the capital of China.(,which)2. He came from a city is in the north of China.(which/that)3. This is the businessman we are cooperating with.(who/whom/that/不填)4. This is Bill Gates many people know as the richest amn.(,whom)注意：非限定性定语从句不仅可以修饰前面的名词，还可以修饰前面的整句话。The company will get back to you in three days,which is one of the typical rules.补充：介词提前的定语从句This is the job which/that/X I have dreamed of for years.This is the job of which I have dreamed of for years.Humans have the ability to modify the environment in which they live.The theory on which it is based may be right.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的补充(复合句/名词性从句)]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85-%E5%A4%8D%E5%90%88%E5%8F%A5-%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第一章 名词性从句一、宾语从句1. 宾语从句的含义：一个句子作宾语，放在另一个句子（主句）里。2. 宾语从句的写法：&emsp;① 陈述句变成宾语从句？You are right.&emsp;&emsp;&emsp;&emsp;↓&emsp;&emsp;&emsp;&emsp;&emsp;I know __.I know (that) you are right.&emsp;② 特殊疑问句变成宾语从句？What will she say?&emsp;&emsp;&emsp;&emsp;↓&emsp;&emsp;&emsp;I know _.I know what she will say.&emsp;③ 一般疑问句变成宾语从句？Is he happy?&emsp;&emsp;&emsp;&emsp;↓&emsp;&emsp;&emsp;&emsp;&emsp;I know __.I know whether/if he is happy.总结：宾语从句的写法____ + ___&emsp;&emsp;(词 + 陈述句)练习：填入宾语从句的连接词1. 我承诺我会帮助你。&emsp;I promise I will help you.2. 你从来没告诉过我，你对我电脑做了什么。&emsp;You never told me you had done to my computer.3. 我想知道什么时候我们将会出发。&emsp;I wonder we will set out.4. 他们不知道他们是否会按时完成工作。&emsp;They don’t know they will finish the work on time.5. 你能告诉我什么时候我们将会出发吗？&emsp; Can you tell me ?答案1. that 2. what 3. when 4. whether 5. when we’ll set out3.宾语从句的位置：名词性从句：6. we know *.7. The big news is *.8. * is big news.9. We know the big news *.宾语从句：1. I don’t know when you will finish the work.No one tells me when you will finish the work.2. I worry about whether I hurt her feelings.3. Are you positive (that) you’ve never seen that man before.二、表语从句My concern is that people don’t care about others.The question remains whether people will buy it.三、同位语从句一个句子作同位语，解释说明 n.位置：需要解释的抽象 n.后。(fact, idea, news, dream, suggestion, advice, report …)最常用的是：“that+陈述句”这种 (注意： that不作成分，但不能省略)我不怀疑他将会帮我的忙。I have no doubt that he will help me.我支持这种论据, 校车问题必须被严肃对待。I support the argument that the problems of school buses must be taken seriously.四、主语从句我们是否将会去露营取决于天气。位置1：句首Whether we will go camping depends on the weather.位置2：句尾(句首用形式主语it)It depends on the weather whether we will go camping.注意：两种位置，意思相同。但更常用的是位于句尾的主语从句。练习： 填入连接词， 并判断是哪种名词性从句。1. ____ Barbara Jones offers to her fans is honesty and happiness.A. Which &emsp;&emsp;B. What &emsp;&emsp;C. That &emsp;&emsp;D. Whom2. We’ve offered her the job, but I don’t know ___ she’ll accept it.A. where &emsp;&emsp;B. what &emsp;&emsp;C. whether &emsp;&emsp;D. which3. Our teachers always tell us to believe in __ we do and who we are if we want to succeed.A. why &emsp;&emsp;B. how &emsp;&emsp;C. what &emsp;&emsp;D. which4. Modern science has given clear evidence ___ smoking can lead to many diseases.A. what &emsp;&emsp;B. which &emsp;&emsp;C. that &emsp;&emsp;D. where5. It was never clear ____ the man hadn’t reported the accident sooner.A. that &emsp;&emsp;B. how &emsp;&emsp;C. when &emsp;&emsp;D. why6. It is still under discussion ___ the old bus station should be replaced with a modern hotel or not.A. whether &emsp;&emsp;B. when &emsp;&emsp;C. which &emsp;&emsp;D. where7. I am afraid he’s more of a talker than a doer, which is ___ he never finishes anything.A. that &emsp;&emsp;B. when &emsp;&emsp;C. where &emsp;&emsp;D. why8. These wild flowers are so special that I would do __ I can to save them.A. whatever &emsp;&emsp;B. which &emsp;&emsp;C. that &emsp;&emsp;D. whichever答案1. B 主语从句 &emsp; 2. C 宾语从句 &emsp; 3. C 宾语从句 &emsp; 4. C 同位语从句5. D 主语从句 &emsp; 6. A 主语从句 &emsp; 7. D 表语从句 &emsp; 8. A 宾语从句]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的补充(并列句)]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85-%E5%B9%B6%E5%88%97%E5%8F%A5.html</url>
    <content type="text"><![CDATA[一、并列句的构成多件事（多个简单句）之间同等重要，用并列连词连接起来。四六级常用的并列连词有：1）&emsp;&emsp;&emsp;表示顺接：…and…;both…and…;not only…,but…as well/but also…2）&emsp;&emsp;&emsp;表示转折：but;yet;while3）&emsp;&emsp;&emsp;表示选择：…or…;either…or…;neither…nor…4）&emsp;&emsp;&emsp;表示因果：…for…（原因）;…so…（结果）二、并列句的省略I am a teacher and I like English.I am a teacher and like English.I am lying in bed and I am reading a book.I am lying in bed and reading a book.I want to leave and I want to go abroad.I want to leave and to go abroad.and(平行结构)练习1. You can stay at home go out to play. It doesn’t matter.A.either,or&emsp;&emsp;B.neither,nor&emsp;&emsp;C.both,and&emsp;&emsp;D.not only,but also2. We bought her a birthday present,_ she likes it very much.A.so&emsp;&emsp;&emsp;B.or&emsp;&emsp;&emsp;C.and&emsp;&emsp;&emsp;D.but3. _ you _ he is able to ski,but I am.A.both,and&emsp;&emsp;B.either,or&emsp;&emsp;C.neither,nor&emsp;&emsp;D.between,and4. The doctor tried their best to save the patient’s life,_failed.A.or&emsp;&emsp;B.so&emsp;&emsp;C.but&emsp;&emsp;D.because5. I could speak _ Japanese _ Chinese,so I had to talk with him in English.A.not only,but also&emsp;&emsp;B.both,and&emsp;&emsp;C.neither,norD.either,or6. I like pop music,but _ my father _ my mother likes it.A.both,and&emsp;&emsp;B.either,or&emsp;&emsp;C.neither,nor&emsp;&emsp;D.not only,but also7. Tom,keep away from the fire, you will get burnt.A.and&emsp;&emsp;B.so&emsp;&emsp;C.or&emsp;&emsp;D.but8. I thought we’d be late for the concert,__ we ended up getting there ahead of time.A.but&emsp;&emsp;B.or&emsp;&emsp;C.so&emsp;&emsp;D.for答案：第一题A第二题C第三题C第四题C第五题C第六题C第七题C第八题A]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的核心变化（同位语/插入语）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E5%8C%96%EF%BC%88%E5%90%8C%E4%BD%8D%E8%AF%AD-%E6%8F%92%E5%85%A5%E8%AF%AD%EF%BC%89.html</url>
    <content type="text"><![CDATA[三、同位语/插入语同位语，解释说明前面名词，与名词相同，说的是一件事。My teacher,Mr. Lee,is coming to the meeting.插入语，插入的补充说明，与前后无关。My teacher,together with his colleagues,is coming to the meeting.All their lives, today’s young women have been pushed to embrace both perfection and passion to pursue science and sports,math and theater and do it all as well as they possibly can.2014.06 CET4Confronted with such facts, some Swedish activists and legislators are demanding more extreme and far-reaching measures,such as replacing male and female pronouns with neutral alternative and monitoring children more closely to correct them when they gravitate toward gendered play.2014.06 CET6]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的补充（非谓语动词）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85%EF%BC%88%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D%EF%BC%89.html</url>
    <content type="text"><![CDATA[二、非谓语动词非谓语动词共3种doing表示主动done表示被动to do表示目的Passing planes can be heard night and day.The teacher came into the classroom,holding a book in his hand.He bought a used car.The teacher came into the classroom, followed by five students.I have a lot of homework to do.I am coming to see you.练习：_, you need to give all you have and try your best.A. Being a winner &emsp;&emsp;&emsp;B. To be a winnerC. Being a winner&emsp;&emsp;&emsp;D. Having been a winner_ into English, the sentence was found to have an entirely different word order.A. Translating&emsp;&emsp;&emsp;&nbsp;B. TranslatedC. To translate&emsp;&emsp;&emsp;D. Having translatedPeter received a letter just now _his grandma would come to see him soon.A. said&emsp;&emsp;&emsp;&emsp;&nbsp;B. saysC. saying&emsp;&emsp;&emsp;D. to say_ an important role in a new movie, Andy has a chance to become famous.A. Offer&emsp;&emsp;&emsp;&emsp;&nbsp;B. OfferingC. Offered&emsp;&emsp;&emsp;D. To offerThe island, __ to the mainland by a bridge,is easy to go to.A. joining&emsp;&emsp;&emsp;B. to joinC. joined&emsp;&emsp;&emsp;D. having joined]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的补充(限定词/形容词/介词短语)]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85-%E9%99%90%E5%AE%9A%E8%AF%8D-%E5%BD%A2%E5%AE%B9%E8%AF%8D-%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD.html</url>
    <content type="text"><![CDATA[一、限定词/形容词/介词短语Girls play games.Girls are playing games.Lovely girls are playing games happily.Thousands of Lovely girls are playing games very happily.After class thousands of Lovely girls are playing games very happily on the playground.常见介词prep. :in on at / from to / into onto / with without / of / by / for / about其他介词 :before after / since until / during / between among / across through / against / like as]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的核心变化（主语/宾语/表语的变化）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E5%8C%96%EF%BC%88%E4%B8%BB%E8%AF%AD-%E5%AE%BE%E8%AF%AD-%E8%A1%A8%E8%AF%AD%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%89.html</url>
    <content type="text"><![CDATA[(二)主语/宾语/表语的变化1. 名词/代词Most graduates always want a big-firm job.She is the leader of the organization.They gave us a good impression.2. doing/to doLaughing probably has great influence on health.To laugh probably has great influence on health.It probably has great influence on health to laugh.Having only a foggy view of the future is of little good.It is no use to talk about dreams without trying.We enjoy reading books in the library.The members of the board decide to vote against the new plan.Our main goal is to finish the task on time.3. 多个并列Science and technology will develop the process of society.Social science disciplines include geography, economics, political science, and psychology.That doesn’t mean sitting down and doing nothing at all.&emsp;&emsp;n. + v.名词/代词&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;动词的时态doing&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;动词的语态to do&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;动词的情态多个并列&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;动词的否态]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的核心变化（情态）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E5%8C%96%EF%BC%88%E6%83%85%E6%80%81%EF%BC%89.html</url>
    <content type="text"><![CDATA[3. 情态用法：情态动词 + 动词原型情态动词的人称变化无情态动词的动态变化有限情态动词变否定/疑问四六级常用的情态动词有：&emsp;现在时&emsp;&emsp;过去时&emsp;must无cancouldwillwouldshallshouldmaymightmust “必须” &emsp;can/could“能够，可以”&emsp;will/would“愿意/将要”may/might“可以，可能”&emsp;should“应该”1 情态动词表示情态We must finish the work within a week.Air pollution must be taken seriously.The government can solve the problem of water pollution.Tony could walk when he was only one year old.Will you marry me?I will travel abroad with my family.Potential buyers would cheer for lower interest rates.To some extent.expressions may influence emotions.Such bodily reaction might help moderate the work stress.Students should work hard to pass the exams.Those sick people should seek help from doctors.2 情态动词表示推测The details may be unknowable.Such searches must take years.The loss of patience can potentially have a damaging impact on our professional and personal wellbeing.The way of saying those things may have led to misunderstanding.Now something similar could be happening in the South Africa.练习：In order to be a good salesclerk, you (must not/will not) be rude to a customer.This pie is very good. You (should/must)try a piece.Rice (should/must/may) have water in order to grow.Don’t be nervous. I think you (can/must) make it.I am not sure. Probably he (may/should) come later.第一题1.must not第二题2.should第三题3.must/should第四题4.can第五题5.may]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的核心变化（语态）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E5%8C%96%EF%BC%88%E8%AF%AD%E6%80%81%EF%BC%89.html</url>
    <content type="text"><![CDATA[2.语态n. + v.动词的时态动词的语态动词的情态谓语动词的变化–&gt;语态被动语态狗吃了那个蛋糕。The dog ate the cake.?吃了那个蛋糕。—-&gt;蛋糕被吃了。狗吃了那个蛋糕。主语&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;宾语蛋糕被狗吃了。被动适用范围 1：及物动词。 2：不及物动词+介词。被动语态 be + done备注：be表示被动的时间 (把be变成对应的各种形态), 还表达主语单复数。done 表示被动的动作教师每天都打扫。Classrooms are cleaned(clean) every day.一座新的大楼去年建造的。A new building was built(build) last year.与时态相结合被动语态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;be + done他每天被打。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;He is beaten every day.他昨天被打了。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;He was beaten yesterday.他明天将要被打。&emsp;&emsp;&emsp;&emsp;&emsp;He will be beaten tomorrow.他现在正在被打。&emsp;&emsp;&emsp;&emsp;&emsp;He is being beaten.(现在进行时的被动am/is/are + being done)他现在已经被打了。&emsp;&emsp;&emsp;&emsp;He has been beaten.(现在完成时的被动have/has + been done)Our morning paper is read(read) by over 200,000 people every day.Last night my favorite TV program was interrupted(interrupt) by a special news bulletin.His bike will be repaired(repair) by his grandfather tomorrow.The new machine has been used(use) in our factory for two week.与情态动词想结合被动语态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;be + donePlanes are heard.Planes can be heard.Planes could be heard.Planes may be heard.Planes must be heard.这封信必须马上寄出。The letter must be sent immediately.天气不能被人们所控制。Weather cannot be controlled by people.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句的核心变化（时态）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E5%8C%96%EF%BC%88%E6%97%B6%E6%80%81%EF%BC%89.html</url>
    <content type="text"><![CDATA[二、简单句的核心变化(一)谓语动词的变化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n. + v.动词的时态动词的语态动词的情态动词的否定1. 时态：时态过去现在将来过去将来一般did/was/weredo/doeswill/am/is/are going to + V.原型would/were/was going to + V.原型进行be + doingbe + doingbe + doingbe + doing完成had + donehave/has+done&emsp;&emsp;完成进行&emsp;have/has been + doing&emsp;&emsp;一般过去时 Simple Past形式：V.过去式(did/was/were)用法：过去的事、过去的动作(无关现在)例子：He was a student.He liked music.She had a boyfriend.变否定或者疑问He was happy.He liked English.He was not happy.He did not like English.Was he happy?Did he like English?What was he?What did he like?补充：&emsp;V.过去式V.过去分词looklookedlookedbuyboughtboughtseesawseeneatateeatenV.过去式&nbsp;&nbsp;&emsp;丨V.过去分词一般过去时&nbsp;&nbsp;丨完成时&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丨被动语态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;丨不做谓语一般现在时 Simple Present形式：V.原型/V.第三人称单数(do/does)You like English.He likes English.用法：1.现在经常性习惯性的动作We have the English class every day.He often gets up late.2.现在的状态I am a teacher.We are in China.3.永恒The earth is round.The earth moves around the sun.Knowledge is power.Practice makes perfect.变否定或者疑问He is happy.You like English.He likes English.He is not happy.You do not like English.He does not like English.Is he happy?Do you like English?Does he like English?How is he?What do you like?What does he like?补充：与频率连用(every,once a week,twice a month,three times a …)alwaysusually,often,frequentlysometimes,occasionallyseldom,hardlynever一般将来时 Simple Future形式：Will/am/is/are going to + V.原型用法：将来的事(现在的将来)I will make a new plan tomorrow.We are going to study abroad next year.变否定或者疑问He will leave.He is going to leave.He will not leave.He is not going to leave.Will he leave?Is he going to leave?What will he?What is he going to do?过去将来时 Past Future形式：Would/was/were going to + V.原型用法：将来的事(过去的将来)I said that I would become a cook in the future.Tony finished his work,and then he would leave for London.三种进行时 Progressive TenseAt 10 o’clock yesterday some students were taking an exam in their classrooms.We are taking about the water pollution.A great many candidates will be meeting here at this time tomorrow.现在完成时 Present Perfect Tense形式：have/has + done用法：现在全部完成 He has left.现在部分完成 We have studied English for ten years.过去完成时 Past Perfect Tense形式：had + done用法：过去的之前When he got there,she had left.She was not there.完成进行时 = “完成” + “进行” =**时间的之前，强调进行的过程角度相同都表示“现在的之前”两种时态现在完成时have/has + done现在完成进行时have/has been + doing强调不同强调结果(做完与否都可以)强调过程例句We have not won the match.We have been working hardfor several months.They on the program for almost one week before I joined them, and now we are still working on it as no good results so far.A.have been working;have come outB.had worked;came outC.had been working;have come outD.have worked;are coming out显示答案答案：C]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github提交表情指南]]></title>
    <url>%2FGithub%E8%A1%A8%E6%83%85%E6%8F%90%E4%BA%A4%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[Github提交表情指南emojiemoji 代码commit 说明:art:(调色板):art:改进代码结构/代码格式:zap:(闪电):racehorse:(赛马):zap: :racehorse:提升性能:fire:(火焰):fire:移除代码或文件:bug:(bug):bug:修复bug:ambulance:(急救车):ambulance:重要补丁:sparkles:(火花):sparkles:引入新功能:memo:(备忘录):memo:撰写文档:rocket:(火箭):rocket:部署功能:lipstick:(口红):lipstick:更新 UI 和样式文件:tada:(庆祝):tada:初次提交:white_check_mark:(白色复选框):white_check_mark:增加测试:lock:(锁):lock:修复安全问题:apple:(苹果:apple:修复 macOS 下的问题:penguin:(企鹅):penguin:修复 Linux 下的问题:checkered_flag:(旗帜):checked_flag:修复 Windows 下的问题:bookmark:(书签):bookmark:发行/版本标签:rotating_light:(警车灯):rotating_light:移除 linter 警告:construction:(施工):construction:工作进行中:green_heart:(绿心):green_heart:修复 CI 构建问题:arrow_down:(下降箭头):arrow_down:降级依赖:arrow_up:(上升箭头):arrow_up:升级依赖:construction_worker:(工人):construction_worker:添加 CI 构建系统:chart_with_upwards_trend:(上升趋势图):chart_with_upwards_trend:添加分析或跟踪代码:hammer:(锤子):hammer:重大重构:heavy_minus_sign: (减号):heavy_minus_sign:减少一个依赖:whale:(鲸鱼):whale:Docker 相关工作:heavy_plus_sign: (加号):heavy_plug_sign:增加一个依赖:wrench:(扳手):wrench:修改配置文件:globe_with_meridians: (地球):globe_with_meridians:国际化与本地化:pencil2:(铅笔):pencil2:修复 typo]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单句]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E5%8F%A5.html</url>
    <content type="text"><![CDATA[第一章：简单句的核心一、简单句的核心构成简单句一个句子（一件事）世界是物质的，物质是运动的 n. + v.主语 + 谓语n. + 谓语 v.一主一谓，谓语动词的不同决定简单句的不同构成。例子I swim.I like English区分vt./vi.1)意思2)介词(prep.)I like English.The bride kissed the groom.Birds fly in the sky.We walked on the street yesterday.You look at me.介宾结构They offered me a vacant post.they offered a vacant post to me.I bought you a present.I bought a present for you.I find HongKong ???I find HongKong very beautiful.I find HongKong a place for shopping.我非常高兴。I very happy. ???I am very happy.主系表系动词be动词 （单独）“变得” get become turn go grow感官动词 look sound smell taste feel“看 / 听 / 闻 / 尝 / 感觉起来…..”keep remain/seem appearFor example:I ask you a question. 主谓双宾You answer. 主谓I love you. 主谓宾You make my life complete. 主谓宾补I am happy. 主系表主语 + 谓语 + ?]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English-Syntax</tag>
      </tags>
  </entry>
</search>
